<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Video Conferencing Platform</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for a clean look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Lucide Icons for UI elements -->
    <script src="https://unpkg.com/lucide-react@0.292.0/dist/lucide-react.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Style for the video elements */
        #localVideo {
            transform: scaleX(-1);
        }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <div id="root"></div>

    <!-- React and Babel for JSX in the browser -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, addDoc, query, where, getDocs } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        import { getDatabase, ref, set, onValue, onDisconnect, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-database.js";

        window.firebase = {
            initializeApp,
            getAuth, signInAnonymously, onAuthStateChanged,
            getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, addDoc, query, where, getDocs,
            getDatabase, ref, set, onValue, onDisconnect, serverTimestamp
        };
    </script>

    <!-- Main Application Logic -->
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const {
            initializeApp
        } = window.firebase;
        const {
            getAuth,
            signInAnonymously,
            onAuthStateChanged
        } = window.firebase;
        const {
            getFirestore,
            collection,
            doc,
            setDoc,
            getDoc,
            addDoc,
            onSnapshot,
            updateDoc,
            deleteDoc
        } = window.firebase;
        const {
            getDatabase,
            ref,
            set,
            onValue,
            onDisconnect,
            serverTimestamp
        } = window.firebase;

        // --- IMPORTANT: Replace with your Firebase project configuration ---
        const firebaseConfig = {
          apiKey: "AIzaSyBluS1Dl9abDJjPPeOhvTCfP8J1kyIh6BQ",
          authDomain: "video-meeting-e73eb.firebaseapp.com",
          projectId: "video-meeting-e73eb",
          storageBucket: "video-meeting-e73eb.firebasestorage.app",
          messagingSenderId: "80496795033",
          appId: "1:80496795033:web:3ac35c631d76301f77c708",
          measurementId: "G-SFPQ0PJRPG"
        };


        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const rtdb = getDatabase(app);

        // WebRTC configuration
        const servers = {
            iceServers: [
                {
                    urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'],
                },
            ],
            iceCandidatePoolSize: 10,
        };

        const App = () => {
            const [page, setPage] = useState('login'); // login, lobby, call
            const [user, setUser] = useState(null);
            const [callData, setCallData] = useState(null);

            useEffect(() => {
                const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
                    if (currentUser && user?.username) {
                        const enrichedUser = { ...user, uid: currentUser.uid };
                        setUser(enrichedUser);
                        setupPresence(enrichedUser);
                    } else {
                        setUser(null);
                    }
                });
                return () => unsubscribe();
            }, [user?.username]);
            
            const setupPresence = (currentUser) => {
                if(!currentUser) return;
                const userStatusDatabaseRef = ref(rtdb, '/status/' + currentUser.uid);
                const isOfflineForDatabase = {
                    state: 'offline',
                    last_changed: serverTimestamp(),
                    username: currentUser.username,
                    isAdmin: currentUser.isAdmin,
                };
                const isOnlineForDatabase = {
                    state: 'online',
                    last_changed: serverTimestamp(),
                    username: currentUser.username,
                    isAdmin: currentUser.isAdmin,
                };
                onValue(ref(rtdb, '.info/connected'), (snapshot) => {
                    if (snapshot.val() === false) {
                        return;
                    }
                    onDisconnect(userStatusDatabaseRef).set(isOfflineForDatabase).then(() => {
                        set(userStatusDatabaseRef, isOnlineForDatabase);
                    });
                });
            };

            const handleLogin = async (username, isAdmin = false) => {
                await signInAnonymously(auth);
                const initialUser = { username, isAdmin };
                // The onAuthStateChanged listener will enrich this user object with a UID
                setUser(initialUser);
                setPage('lobby');
            };

            const handleStartCall = (callee) => {
                setCallData({ caller: user, callee });
                setPage('call');
            };
            
            const handleJoinCall = (callInfo) => {
                setCallData(callInfo);
                setPage('call');
            };

            const handleLeaveCall = () => {
                setCallData(null);
                setPage('lobby');
            };

            return (
                <div className="min-h-screen flex flex-col items-center justify-center p-4 bg-gray-900">
                    {page === 'login' && <Login onLogin={handleLogin} />}
                    {page === 'lobby' && user && <Lobby user={user} onStartCall={handleStartCall} onJoinCall={handleJoinCall} />}
                    {page === 'call' && user && callData && <VideoCallRoom user={user} callData={callData} onLeaveCall={handleLeaveCall} />}
                </div>
            );
        };

        const Login = ({ onLogin }) => {
            const [username, setUsername] = useState('');
            const [password, setPassword] = useState('');
            const [showPassword, setShowPassword] = useState(false);
            const [error, setError] = useState('');

            useEffect(() => {
                if (username.toLowerCase() === 'admin') {
                    setShowPassword(true);
                } else {
                    setShowPassword(false);
                    setPassword('');
                }
            }, [username]);

            const handleSubmit = (e) => {
                e.preventDefault();
                setError('');
                if (!username.trim()) {
                    setError('Username cannot be empty.');
                    return;
                }
                if (username.toLowerCase() === 'admin') {
                    if (password === 'max') {
                        onLogin(username, true);
                    } else {
                        setError('Incorrect admin password.');
                    }
                } else {
                    onLogin(username);
                }
            };

            return (
                <div className="w-full max-w-sm p-8 space-y-6 bg-gray-800 rounded-xl shadow-lg">
                    <h1 className="text-3xl font-bold text-center text-white">Join Conference</h1>
                    <form onSubmit={handleSubmit} className="space-y-6">
                        <div>
                            <label htmlFor="username" className="text-sm font-medium text-gray-300">Username</label>
                            <input
                                id="username"
                                type="text"
                                value={username}
                                onChange={(e) => setUsername(e.target.value)}
                                className="w-full px-4 py-2 mt-2 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                                placeholder="Enter your username"
                            />
                        </div>
                        {showPassword && (
                            <div className="transition-all duration-300">
                                <label htmlFor="password"  className="text-sm font-medium text-gray-300">Admin Password</label>
                                <input
                                    id="password"
                                    type="password"
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    className="w-full px-4 py-2 mt-2 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                                    placeholder="Enter password"
                                />
                            </div>
                        )}
                        {error && <p className="text-sm text-red-400">{error}</p>}
                        <button type="submit" className="w-full px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-blue-500 transition-colors">
                            Join Lobby
                        </button>
                    </form>
                </div>
            );
        };

        const Lobby = ({ user, onStartCall, onJoinCall }) => {
            const [users, setUsers] = useState([]);
            const [messages, setMessages] = useState([]);
            const [newMessage, setNewMessage] = useState('');
            const chatEndRef = useRef(null);
            
            // Listen for incoming calls
            useEffect(() => {
                if (!user || user.isAdmin) return;

                const q = collection(db, 'calls');
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const callData = change.doc.data();
                            if (callData.callee.uid === user.uid && !callData.answer) {
                                const confirmed = window.confirm(`Incoming call from ${callData.caller.username}. Do you want to accept?`);
                                if (confirmed) {
                                    onJoinCall({ ...callData, callId: change.doc.id });
                                }
                            }
                        }
                    });
                });
                return () => unsubscribe();
            }, [user, onJoinCall]);


            // User presence listener
            useEffect(() => {
                const statusRef = ref(rtdb, 'status');
                const unsubscribe = onValue(statusRef, (snapshot) => {
                    const statuses = snapshot.val() || {};
                    const onlineUsers = Object.entries(statuses)
                        .filter(([, status]) => status.state === 'online')
                        .map(([uid, status]) => ({ uid, ...status }));
                    setUsers(onlineUsers);
                });
                return () => unsubscribe();
            }, []);

            // Chat listener
            useEffect(() => {
                const chatRef = ref(rtdb, 'chat');
                const unsubscribe = onValue(chatRef, (snapshot) => {
                    const msgs = snapshot.val() || {};
                    const formattedMessages = Object.values(msgs).sort((a, b) => a.timestamp - b.timestamp);
                    setMessages(formattedMessages);
                });
                return () => unsubscribe();
            }, []);
            
            useEffect(() => {
                chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [messages]);

            const handleSendMessage = (e) => {
                e.preventDefault();
                if (!newMessage.trim()) return;
                const chatRef = ref(rtdb, `chat/${Date.now()}`);
                set(chatRef, {
                    username: user.username,
                    message: newMessage,
                    timestamp: serverTimestamp(),
                    uid: user.uid
                });
                setNewMessage('');
            };

            return (
                <div className="w-full max-w-6xl h-[80vh] flex space-x-4">
                    {/* User List */}
                    <div className="w-1/4 bg-gray-800 rounded-xl p-4 flex flex-col">
                        <h2 className="text-xl font-bold mb-4 border-b border-gray-700 pb-2">Active Users ({users.length})</h2>
                        <ul className="space-y-2 overflow-y-auto">
                            {users.map((u) => (
                                <li key={u.uid} className="flex items-center justify-between p-2 bg-gray-700 rounded-md">
                                    <span className={`font-medium ${u.uid === user.uid ? 'text-blue-400' : ''}`}>
                                        {u.username} {u.uid === user.uid ? '(You)' : ''}
                                    </span>
                                    {user.isAdmin && u.uid !== user.uid && (
                                        <button onClick={() => onStartCall(u)} className="p-1.5 bg-green-500 rounded-full hover:bg-green-600">
                                            <lucide-react.Phone size={16} />
                                        </button>
                                    )}
                                </li>
                            ))}
                        </ul>
                    </div>
                    {/* Chat Area */}
                    <div className="w-3/4 bg-gray-800 rounded-xl flex flex-col p-4">
                        <h2 className="text-xl font-bold mb-4 border-b border-gray-700 pb-2">Lobby Chat</h2>
                        <div className="flex-1 overflow-y-auto mb-4 pr-2 space-y-4">
                            {messages.map((msg, index) => (
                                <div key={index} className={`flex ${msg.uid === user.uid ? 'justify-end' : 'justify-start'}`}>
                                    <div className={`p-3 rounded-lg max-w-md ${msg.uid === user.uid ? 'bg-blue-600' : 'bg-gray-700'}`}>
                                        <p className="text-xs text-gray-300 font-semibold">{msg.username}</p>
                                        <p className="text-white">{msg.message}</p>
                                    </div>
                                </div>
                            ))}
                            <div ref={chatEndRef} />
                        </div>
                        <form onSubmit={handleSendMessage} className="flex space-x-2">
                            <input
                                type="text"
                                value={newMessage}
                                onChange={(e) => setNewMessage(e.target.value)}
                                className="flex-1 px-4 py-2 text-white bg-gray-700 border border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                                placeholder="Type a message..."
                            />
                            <button type="submit" className="px-4 py-2 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">
                                Send
                            </button>
                        </form>
                    </div>
                </div>
            );
        };

        const VideoCallRoom = ({ user, callData, onLeaveCall }) => {
            const localVideoRef = useRef();
            const remoteVideoRef = useRef();
            const pc = useRef(new RTCPeerConnection(servers));
            
            const [localStream, setLocalStream] = useState(null);
            const [remoteStream, setRemoteStream] = useState(null);
            const [callId, setCallId] = useState(null);
            
            const [isMuted, setIsMuted] = useState(false);
            const [isVideoOff, setIsVideoOff] = useState(false);

            const isCaller = user.uid === callData.caller.uid;

            // Setup streams and peer connection
            const setupStreamsAndPC = useCallback(async () => {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                setLocalStream(stream);
                
                stream.getTracks().forEach((track) => {
                    pc.current.addTrack(track, stream);
                });
    
                pc.current.ontrack = (event) => {
                    setRemoteStream(event.streams[0]);
                };

                if (localVideoRef.current) {
                  localVideoRef.current.srcObject = stream;
                }

            }, []);
            
            // Hangup logic
            const hangUp = useCallback(async () => {
                localStream?.getTracks().forEach((track) => track.stop());
                pc.current.close();
                if(callId) {
                    const callDocRef = doc(db, 'calls', callId);
                    const callDoc = await getDoc(callDocRef);
                    if (callDoc.exists()) {
                       await deleteDoc(callDocRef);
                    }
                }
                onLeaveCall();
            }, [localStream, callId, onLeaveCall]);

            // Call logic (creating and answering)
            useEffect(() => {
                const startCall = async () => {
                    await setupStreamsAndPC();
                    const callDocRef = doc(collection(db, 'calls'));
                    setCallId(callDocRef.id);
                    
                    const callerCandidatesCollection = collection(callDocRef, 'callerCandidates');
                    const calleeCandidatesCollection = collection(callDocRef, 'calleeCandidates');
                    
                    pc.current.onicecandidate = (event) => {
                        event.candidate && addDoc(callerCandidatesCollection, event.candidate.toJSON());
                    };
                    
                    const offerDescription = await pc.current.createOffer();
                    await pc.current.setLocalDescription(offerDescription);
                    
                    const offer = {
                        sdp: offerDescription.sdp,
                        type: offerDescription.type,
                    };
                    
                    await setDoc(callDocRef, { offer, caller: callData.caller, callee: callData.callee });
                    
                    // Listen for answer
                    const unsubscribe = onSnapshot(callDocRef, (snapshot) => {
                        const data = snapshot.data();
                        if (!pc.current.currentRemoteDescription && data?.answer) {
                            const answerDescription = new RTCSessionDescription(data.answer);
                            pc.current.setRemoteDescription(answerDescription);
                        }
                    });

                    // Listen for ICE candidates from callee
                    const unsubscribeCandidates = onSnapshot(calleeCandidatesCollection, (snapshot) => {
                        snapshot.docChanges().forEach((change) => {
                            if (change.type === 'added') {
                                const candidate = new RTCIceCandidate(change.doc.data());
                                pc.current.addIceCandidate(candidate);
                            }
                        });
                    });
                    
                    return () => {
                        unsubscribe();
                        unsubscribeCandidates();
                    };
                };

                const answerCall = async () => {
                    await setupStreamsAndPC();
                    const callDocRef = doc(db, 'calls', callData.callId);
                    setCallId(callData.callId);

                    const callerCandidatesCollection = collection(callDocRef, 'callerCandidates');
                    const calleeCandidatesCollection = collection(callDocRef, 'calleeCandidates');

                    pc.current.onicecandidate = (event) => {
                        event.candidate && addDoc(calleeCandidatesCollection, event.candidate.toJSON());
                    };

                    const callDoc = await getDoc(callDocRef);
                    const callInfo = callDoc.data();
                    
                    await pc.current.setRemoteDescription(new RTCSessionDescription(callInfo.offer));

                    const answerDescription = await pc.current.createAnswer();
                    await pc.current.setLocalDescription(answerDescription);

                    const answer = {
                        type: answerDescription.type,
                        sdp: answerDescription.sdp,
                    };

                    await updateDoc(callDocRef, { answer });
                    
                    // Listen for ICE candidates from caller
                    const unsubscribe = onSnapshot(callerCandidatesCollection, (snapshot) => {
                        snapshot.docChanges().forEach((change) => {
                            if (change.type === 'added') {
                                const candidate = new RTCIceCandidate(change.doc.data());
                                pc.current.addIceCandidate(candidate);
                            }
                        });
                    });

                    return () => unsubscribe();
                };

                if (isCaller) {
                    startCall();
                } else {
                    answerCall();
                }

                // Listener to detect if the other user hangs up
                if(callId || callData.callId){
                    const currentCallId = callId || callData.callId;
                    const callDocRef = doc(db, 'calls', currentCallId);
                    const unsubscribeHangup = onSnapshot(callDocRef, (doc) => {
                        if (!doc.exists()) {
                            hangUp();
                        }
                    });
                    return () => unsubscribeHangup();
                }

            }, [isCaller, setupStreamsAndPC, hangUp, callData]);
            
            useEffect(() => {
                if (localStream) {
                    localVideoRef.current.srcObject = localStream;
                }
            }, [localStream]);
            
            useEffect(() => {
                if (remoteStream) {
                    remoteVideoRef.current.srcObject = remoteStream;
                }
            }, [remoteStream]);

            const toggleMute = () => {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = !track.enabled;
                    setIsMuted(!track.enabled);
                });
            };

            const toggleVideo = () => {
                localStream.getVideoTracks().forEach(track => {
                    track.enabled = !track.enabled;
                    setIsVideoOff(!track.enabled);
                });
            };

            return (
                <div className="w-full h-screen flex flex-col items-center justify-center bg-gray-900 p-4 relative">
                    <div className="relative w-full h-full max-w-6xl rounded-xl overflow-hidden shadow-2xl">
                        {/* Remote Video */}
                        <video ref={remoteVideoRef} autoPlay playsInline className="w-full h-full object-cover bg-gray-800" />
                        
                        {/* Local Video */}
                        <div className="absolute top-4 right-4 w-1/4 max-w-[250px] rounded-lg overflow-hidden border-2 border-gray-700 shadow-lg">
                           <video ref={localVideoRef} id="localVideo" autoPlay playsInline muted className="w-full h-full object-cover bg-gray-700" />
                        </div>

                        {!remoteStream && (
                            <div className="absolute inset-0 flex items-center justify-center bg-gray-800 bg-opacity-75">
                                <div className="text-center">
                                    <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-400 mx-auto"></div>
                                    <p className="mt-4 text-xl">Connecting to {isCaller ? callData.callee.username : callData.caller.username}...</p>
                                </div>
                            </div>
                        )}
                    </div>
                    
                    {/* Controls */}
                    <div className="absolute bottom-6 flex items-center space-x-4 bg-gray-800 bg-opacity-70 p-4 rounded-full">
                        <button onClick={toggleMute} className={`p-3 rounded-full transition-colors ${isMuted ? 'bg-yellow-500 hover:bg-yellow-600' : 'bg-gray-600 hover:bg-gray-500'}`}>
                            {isMuted ? <lucide-react.MicOff size={24} /> : <lucide-react.Mic size={24} />}
                        </button>
                        <button onClick={toggleVideo} className={`p-3 rounded-full transition-colors ${isVideoOff ? 'bg-yellow-500 hover:bg-yellow-600' : 'bg-gray-600 hover:bg-gray-500'}`}>
                           {isVideoOff ? <lucide-react.VideoOff size={24} /> : <lucide-react.Video size={24} />}
                        </button>
                        <button onClick={hangUp} className="p-3 bg-red-600 hover:bg-red-700 rounded-full">
                            <lucide-react.PhoneOff size={24} />
                        </button>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
