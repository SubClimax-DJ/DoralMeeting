<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Doral Video Conference</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600&family=Lato:wght@400;700&display=swap');
body {
font-family: 'Lato', sans-serif;
background-color: #282828;
color: #ebdbb2;
}
.header {
background-color: #1d2021;
color: #ebdbb2;
}
.container-card {
background-color: #32302f;
border-radius: 0.5rem;
padding: 2rem;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}
.btn-primary {
@apply px-6 py-3 font-semibold rounded-sm transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2;
background-color: #458588;
color: #ebdbb2;
}
.btn-danger {
@apply px-6 py-3 font-semibold rounded-sm transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2;
background-color: #fb4934;
color: #ebdbb2;
}
.btn-toggle {
@apply px-4 py-2 font-semibold rounded-sm transition duration-300 focus:outline-none;
background-color: #504945;
color: #ebdbb2;
}
.btn-toggle-active {
@apply px-4 py-2 font-semibold rounded-sm transition duration-300 focus:outline-none;
background-color: #b8bb26;
color: #1d2021;
}
.input-field {
@apply w-full px-4 py-3 rounded-sm border border-gray-600 focus:outline-none focus:ring-2 transition duration-200;
background-color: #32302f;
color: #ebdbb2;
}
.video-container {
position: relative;
width: 100%;
padding-top: 56.25%; /* 16:9 Aspect Ratio */
background-color: #1d2021;
border-radius: 0.5rem;
overflow: hidden;
}
.video-element {
width: 100%;
height: 100%;
object-fit: cover;
transition: all 0.3s ease-in-out;
}
#localVideo {
width: 150px;
height: 112.5px;
position: absolute;
bottom: 1rem;
right: 1rem;
border-radius: 0.25rem;
z-index: 10;
border: 2px solid #ebdbb2;
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
}
#remoteVideo {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
object-fit: cover;
transition: all 0.3s ease-in-out;
z-index: 5; /* Ensure remote video is below local video by default */
}
.chat-container {
background-color: #3c3836;
border: 1px solid #504945;
border-radius: 0.5rem;
height: 500px;
overflow-y: auto;
display: flex;
flex-direction: column-reverse;
}
.message {
padding: 0.5rem 1rem;
margin: 0.5rem;
border-radius: 0.75rem;
max-width: 85%;
word-wrap: break-word;
}
.my-message {
background-color: #458588;
color: #ebdbb2;
align-self: flex-end;
}
.other-message {
background-color: #665c54;
color: #ebdbb2;
align-self: flex-start;
}
.modal-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.7);
display: flex;
justify-content: center;
align-items: center;
z-index: 50;
}
.modal-content {
background-color: #32302f;
padding: 2rem;
border-radius: 0.5rem;
box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
width: 90%;
max-width: 400px;
}
.sakura-container {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
overflow: hidden;
z-index: 20; /* Above videos */
}
.sakura-petal {
position: absolute;
background: rgba(255, 192, 203, 0.8);
border-radius: 50%;
width: 10px;
height: 10px;
animation: falling 15s linear infinite;
}
@keyframes falling {
0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; }
100% { transform: translateY(110vh) rotate(360deg); opacity: 0; }
}
.video-grid {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
gap: 1rem;
width: 100%;
height: 100%;
}
</style>
</head>
<body class="flex flex-col items-center min-h-screen p-4">

<!-- Header -->
<header class="header w-full py-4 mb-8 flex flex-col sm:flex-row items-center justify-between px-6 shadow-md">
<div class="flex items-center">
<img src="https://content.enrollmystudent.org/contact_school_logo/school_logo_1655490559.jpg" alt="School Logo" class="h-12 mr-4">
<div class="flex flex-col items-start">
<h1 class="text-3xl sm:text-4xl font-semibold font-['Crimson_Pro']">
Doral Video Conference
</h1>
<p class="text-sm font-light text-gray-400 mt-1">Created by Coach Prebeg</p>
</div>
</div>
<div class="text-sm mt-2 sm:mt-0 font-light" id="auth-status">Authenticating...</div>
</header>

<!-- Main App Content (hidden initially) -->
<main id="mainApp" class="w-full max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-4 gap-8 hidden">
<!-- Left Sidebar for Chat -->
<div class="md:col-span-1 space-y-8">
<div class="container-card">
<h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Chat</h2>
<div class="chat-container mb-4" id="chatContainer"></div>
<div class="flex space-x-2">
<input type="text" id="chatInput" placeholder="Send a message..." class="input-field flex-1" />
<button id="sendChatBtn" class="btn-primary" disabled>Send</button>
</div>
</div>
</div>

<!-- Video and Controls -->
<div class="md:col-span-2 container-card">
<h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Video Feed</h2>
<div class="video-container mb-4">
<div class="video-grid" id="videoGrid"></div>
</div>
<div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 items-center justify-center">
<button id="toggleAudioBtn" class="btn-toggle" disabled><i class="fas fa-microphone"></i> Mute Audio</button>
<button id="toggleVideoBtn" class="btn-toggle" disabled><i class="fas fa-video"></i> Mute Video</button>
<button id="screenShareBtn" class="btn-toggle" disabled><i class="fas fa-desktop"></i> Screen Share</button>
<button id="fullScreenBtn" class="btn-toggle" disabled><i class="fas fa-expand"></i> Fullscreen</button>
<button id="sideBySideBtn" class="btn-toggle" disabled><i class="fas fa-columns"></i> Side-by-Side</button>
<button id="hangupBtn" class="btn-danger flex-1" disabled>Leave Room</button>
</div>
<div class="flex mt-4 space-x-4 items-center justify-center">
<i class="fas fa-volume-down text-lg"></i>
<input type="range" id="volumeControl" min="0" max="100" value="100" class="flex-1 cursor-pointer">
<i class="fas fa-volume-up text-lg"></i>
</div>
<div class="flex mt-4 space-x-4 justify-center">
<button id="startRecordingBtn" class="btn-primary" disabled>Start Recording</button>
<button id="stopRecordingBtn" class="btn-danger" disabled>Stop Recording</button>
</div>
<a id="downloadRecording" style="display: none;"></a>
</div>

<!-- Right Sidebar for Management -->
<div class="md:col-span-1 space-y-8">
<div class="container-card">
<h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Room Management</h2>
<div class="flex flex-col space-y-4">
<div class="flex space-x-2">
<input type="text" id="roomIdInput" placeholder="Enter Room ID" class="input-field flex-1" />
<button id="joinRoomBtn" class="btn-primary" disabled>Join</button>
</div>
<div class="flex items-center space-x-2">
<input type="checkbox" id="joinMutedCheckbox" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500">
<label for="joinMutedCheckbox" class="text-sm">Join with camera/mic off</label>
</div>
<div class="flex items-center space-x-2">
<label for="videoQualitySelect" class="text-sm">Video Quality:</label>
<select id="videoQualitySelect" class="input-field flex-1">
<option value="480p">SD (480p)</option>
<option value="720p">HD (720p)</option>
<option value="1080p">Full HD (1080p)</option>
</select>
</div>
<button id="createRoomBtn" class="btn-primary" disabled>Create New Room</button>
<button id="deleteAllRoomsBtn" class="btn-danger" disabled>Delete All Rooms</button>
<button id="lockRoomBtn" class="btn-toggle" disabled>Lock Room</button>
</div>
</div>

<div class="container-card">
<h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Active Rooms</h2>
<div id="activeRoomsList" class="space-y-2">
<p class="text-gray-500 text-sm">Loading rooms...</p>
</div>
</div>

<div class="container-card">
<h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Participants</h2>
<div id="participantsList" class="space-y-2 text-gray-400 text-sm">
No participants in this room.
</div>
</div>

<div class="container-card">
<h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Active Users</h2>
<div id="activeUsersList" class="space-y-2 text-gray-400 text-sm">
Loading users...
</div>
</div>
</div>
</main>

<!-- Initial Username Prompt -->
<div id="usernamePrompt" class="md:col-span-3 flex flex-col items-center justify-center p-8 bg-[#32302f] rounded-lg shadow-xl absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-4/5 md:w-1/2">
<h2 class="text-2xl font-bold font-['Crimson_Pro'] mb-4">Enter Your Username</h2>
<p class="text-sm text-gray-400 mb-6 text-center">Your username will be visible to other participants in the chat.</p>
<input type="text" id="usernameInput" placeholder="Your Name" class="input-field max-w-sm mb-4" />
<button id="submitUsernameBtn" class="btn-primary max-w-xs w-full">Start</button>
</div>

<!-- Password Modal (Hidden by default) -->
<div id="passwordModal" class="modal-overlay hidden">
<div class="modal-content flex flex-col space-y-4">
<h2 class="text-xl font-bold font-['Crimson_Pro']" id="passwordModalTitle">Enter Password</h2>
<p class="text-sm text-gray-400" id="passwordModalText">To delete all rooms, please enter the administrator password.</p>
<input type="password" id="passwordInput" placeholder="Password" class="input-field" />
<div class="flex space-x-4">
<button id="confirmBtn" class="btn-danger flex-1" data-action="">Confirm</button>
<button id="cancelBtn" class="btn-toggle flex-1">Cancel</button>
</div>
</div>
</div>

<!-- Global Status Message -->
<div id="status-message" class="fixed bottom-4 left-1/2 -translate-x-1/2 p-4 rounded-lg text-sm text-center text-gray-700 bg-gray-100 hidden"></div>

<!-- Font Awesome Icons -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/js/all.min.js"></script>

<!-- Firebase SDKs -->
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, setLogLevel, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

// Hardcoded Firebase configuration
const hardcodedFirebaseConfig = {
  apiKey: "AIzaSyBluS1Dl9abDJjPPeOhvTCfP8J1kyIh6BQ",
  authDomain: "video-meeting-e73eb.firebaseapp.com",
  projectId: "video-meeting-e73eb",
  storageBucket: "video-meeting-e73eb.firebasestorage.app",
  messagingSenderId: "80496795033",
  appId: "1:80496795033:web:3ac35c631d76301f77c708",
  measurementId: "G-SFPQ0PJRPG"
};

// Use the environment's config if available, otherwise use the hardcoded one
const firebaseConfig = typeof __firebase_config !== 'undefined' && __firebase_config !== '{}'
    ? JSON.parse(__firebase_config)
    : hardcodedFirebaseConfig;

// Global variables provided by the environment
const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.appId;
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// UI Elements
const usernamePrompt = document.getElementById('usernamePrompt');
const mainApp = document.getElementById('mainApp');
const usernameInput = document.getElementById('usernameInput');
const submitUsernameBtn = document.getElementById('submitUsernameBtn');
const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');
const roomIdInput = document.getElementById('roomIdInput');
const createRoomBtn = document.getElementById('createRoomBtn');
const joinRoomBtn = document.getElementById('joinRoomBtn');
const deleteAllRoomsBtn = document.getElementById('deleteAllRoomsBtn');
const lockRoomBtn = document.getElementById('lockRoomBtn');
const hangupBtn = document.getElementById('hangupBtn');
const toggleAudioBtn = document.getElementById('toggleAudioBtn');
const toggleVideoBtn = document.getElementById('toggleVideoBtn');
const screenShareBtn = document.getElementById('screenShareBtn');
const fullScreenBtn = document.getElementById('fullScreenBtn');
const sideBySideBtn = document.getElementById('sideBySideBtn');
const videoQualitySelect = document.getElementById('videoQualitySelect');
const volumeControl = document.getElementById('volumeControl');
const startRecordingBtn = document.getElementById('startRecordingBtn');
const stopRecordingBtn = document.getElementById('stopRecordingBtn');
const chatInput = document.getElementById('chatInput');
const sendChatBtn = document.getElementById('sendChatBtn');
const chatContainer = document.getElementById('chatContainer');
const statusMessage = document.getElementById('status-message');
const authStatus = document.getElementById('auth-status');
const activeRoomsList = document.getElementById('activeRoomsList');
const joinMutedCheckbox = document.getElementById('joinMutedCheckbox');
const participantsList = document.getElementById('participantsList');
const activeUsersList = document.getElementById('activeUsersList');
const sakuraEffect = document.getElementById('sakuraEffect');
const videoGrid = document.getElementById('videoGrid');

// Password Modal Elements
const passwordModal = document.getElementById('passwordModal');
const passwordModalTitle = document.getElementById('passwordModalTitle');
const passwordModalText = document.getElementById('passwordModalText');
const passwordInput = document.getElementById('passwordInput');
const confirmBtn = document.getElementById('confirmBtn');
const cancelBtn = document.getElementById('cancelBtn');

// Firestore and Auth instances
let app, db, auth;
let userId;

// User-specific variables
let username;
let isCreator = false;

// WebRTC variables
let peerConnections = {};
let localStream = null;
let roomRef = null;
let roomSnapshotListener = null;
let candidatesListeners = {};
let chatListener = null;
let roomsListener = null;
let participantsListener = null;
let activeUsersListener = null;
let isScreenSharing = false;

// Recording variables
let mediaRecorder;
let recordedChunks = [];

// Video quality options
const videoQualities = {
  '480p': { width: 640, height: 480 },
  '720p': { width: 1280, height: 720 },
  '1080p': { width: 1920, height: 1080 }
};

// WebRTC STUN servers
const configuration = {
iceServers: [
{ urls: 'stun:stun.l.google.com:19302' },
{ urls: 'stun:stun1.l.google.com:19302' },
]
};

// Function to display messages to the user
const showMessage = (msg, isError = false) => {
statusMessage.textContent = msg;
statusMessage.className = `fixed bottom-4 left-1/2 -translate-x-1/2 p-4 rounded-lg text-sm text-center transition-all duration-300 transform animate-fade-in ${isError ? 'text-red-700 bg-red-100' : 'text-gray-700 bg-gray-100'}`;
statusMessage.style.display = 'block';
};

// Function to hide the status message
const hideMessage = () => {
statusMessage.style.display = 'none';
};

// Initialize Firebase and Auth
const initFirebase = async () => {
try {
app = initializeApp(firebaseConfig);
db = getFirestore(app);
auth = getAuth(app);
setLogLevel('debug');

onAuthStateChanged(auth, async (user) => {
if (user) {
userId = user.uid;
authStatus.textContent = `User ID: ${userId}`;
createRoomBtn.disabled = false;
joinRoomBtn.disabled = false;
deleteAllRoomsBtn.disabled = false;
listenForRooms();
listenForActiveUsers();
} else {
authStatus.textContent = 'Authenticating...';
try {
if (initialAuthToken) {
await signInWithCustomToken(auth, initialAuthToken);
} else {
await signInAnonymously(auth);
}
} catch (error) {
console.error("Firebase Auth Error:", error);
showMessage("Authentication failed.", true);
}
}
});
} catch (error) {
console.error("Firebase Initialization Error:", error);
showMessage(`Firebase initialization failed: ${error.message}`, true);
}
};

// Get the user's local video and audio stream
const getLocalStream = async () => {
try {
  const selectedQuality = videoQualitySelect.value;
  const constraints = {
    audio: true,
    video: videoQualities[selectedQuality]
  };

localStream = await navigator.mediaDevices.getUserMedia(constraints);
localVideo.srcObject = localStream;
localVideo.muted = true;
addLocalVideoToGrid();

toggleAudioBtn.disabled = false;
toggleVideoBtn.disabled = false;
fullScreenBtn.disabled = false;
sideBySideBtn.disabled = false;
lockRoomBtn.disabled = false;
videoQualitySelect.disabled = false;
screenShareBtn.disabled = false;

return localStream;
} catch (error) {
console.error("Error getting user media:", error);
if (error.name === "NotAllowedError" || error.name === "PermissionDeniedError") {
showMessage("Access to camera/microphone was denied. Please check your browser's settings.", true);
} else {
showMessage("Could not access camera and microphone. Please grant permissions.", true);
}
return null;
} finally {
if (!localStream) {
hideMessage();
}
}
};

const getDisplayStream = async () => {
    try {
        const constraints = { video: true, audio: true };
        const displayStream = await navigator.mediaDevices.getDisplayMedia(constraints);
        localVideo.srcObject = displayStream;

        localVideo.muted = true;
        toggleAudioBtn.disabled = false;
        toggleVideoBtn.disabled = false;

        // Listen for the end of screen share
        displayStream.getVideoTracks()[0].onended = () => {
            hangup();
        };

        return displayStream;
    } catch (error) {
        console.error("Error getting display media:", error);
        showMessage("Screen sharing was cancelled or failed.", true);
        return null;
    }
};

// Set up the WebRTC peer connection for a new user
const setupPeerConnection = (remoteUserId) => {
const peerConnection = new RTCPeerConnection(configuration);
peerConnections[remoteUserId] = peerConnection;

localStream.getTracks().forEach(track => {
  peerConnection.addTrack(track, localStream);
});

peerConnection.onicecandidate = (event) => {
  if (event.candidate) {
    const candidatesCollection = collection(roomRef, `candidates/${remoteUserId}/user-candidates`);
    addDoc(candidatesCollection, { candidate: JSON.stringify(event.candidate.toJSON()), sender: userId });
  }
};

peerConnection.ontrack = (event) => {
  if (event.streams && event.streams[0]) {
    addRemoteVideoToGrid(remoteUserId, event.streams[0]);
  }
};

return peerConnection;
};

// Add a video element for the local user
const addLocalVideoToGrid = () => {
  const localVideoContainer = document.getElementById('localVideoContainer');
  if (localVideoContainer) {
    localVideoContainer.remove();
  }
  const videoWrapper = document.createElement('div');
  videoWrapper.id = 'localVideoContainer';
  videoWrapper.classList.add('video-element');
  videoWrapper.appendChild(localVideo);
  videoGrid.appendChild(videoWrapper);
}

// Add a video element for a remote user
const addRemoteVideoToGrid = (remoteUserId, stream) => {
  const existingVideo = document.getElementById(`video-${remoteUserId}`);
  if (existingVideo) {
    existingVideo.srcObject = stream;
    return;
  }
  const videoWrapper = document.createElement('div');
  videoWrapper.id = `video-${remoteUserId}`;
  videoWrapper.classList.add('video-element');
  const video = document.createElement('video');
  video.srcObject = stream;
  video.autoplay = true;
  video.playsinline = true;
  video.classList.add('w-full', 'h-full', 'object-cover');
  videoWrapper.appendChild(video);
  videoGrid.appendChild(videoWrapper);
}

// Remove a video element when a user leaves
const removeVideoFromGrid = (remoteUserId) => {
  const videoElement = document.getElementById(`video-${remoteUserId}`);
  if (videoElement) {
    videoElement.remove();
  }
}

// Listen for and display active rooms
const listenForRooms = () => {
if (roomsListener) {
roomsListener();
}
const roomsCollectionRef = collection(db, `artifacts/${appId}/public/data/video-rooms`);
roomsListener = onSnapshot(roomsCollectionRef, (snapshot) => {
activeRoomsList.innerHTML = '';
if (snapshot.empty) {
activeRoomsList.innerHTML = '<p class="text-gray-500 text-sm">No active rooms.</p>';
} else {
snapshot.forEach(doc => {
const roomData = doc.data();
const roomName = doc.id;
const numParticipants = Object.keys(roomData.participants || {}).length;
const isOccupied = numParticipants > 1;

const statusIcon = isOccupied
? '<i class="fas fa-lock text-red-500"></i>'
: '<i class="fas fa-check-circle text-green-500"></i>';

const roomDiv = document.createElement('div');
roomDiv.className = 'flex items-center justify-between p-2 bg-[#3c3836] rounded-sm hover:bg-[#504945] transition duration-150 cursor-pointer';
roomDiv.innerHTML = `
<div class="flex items-center space-x-2">
<span>${statusIcon}</span>
<div class="flex flex-col">
<span class="font-semibold">${roomName}</span>
<span class="text-xs text-gray-400">Created by: ${roomData.createdByUsername}</span>
</div>
</div>
<button data-room-id="${roomName}" class="join-room-btn px-3 py-1 text-sm rounded-sm bg-blue-600 text-white hover:bg-blue-700">Join</button>
`;
activeRoomsList.appendChild(roomDiv);
});
document.querySelectorAll('.join-room-btn').forEach(button => {
button.addEventListener('click', (e) => {
roomIdInput.value = e.target.dataset.roomId;
joinRoom();
});
});
}
});
};

// Create a new video room
const createRoom = async () => {
if (!userId) {
showMessage("Authentication in progress. Please wait.", true);
return;
}
isCreator = true;
const roomName = `room-${Math.random().toString(36).substring(2, 9)}`;
roomIdInput.value = roomName;
roomRef = doc(db, `artifacts/${appId}/public/data/video-rooms`, roomName);

showMessage("Creating room...");

const startMuted = joinMutedCheckbox.checked;
if (startMuted) {
  localStream.getAudioTracks()[0].enabled = false;
  localStream.getVideoTracks()[0].enabled = false;
  toggleAudioBtn.textContent = "Unmute Audio";
  toggleVideoBtn.textContent = "Turn On Video";
} else {
  localStream.getAudioTracks()[0].enabled = true;
  localStream.getVideoTracks()[0].enabled = true;
  toggleAudioBtn.textContent = "Mute Audio";
  toggleVideoBtn.textContent = "Mute Video";
}

const participants = { 
  [userId]: {
    username: username,
    isMuted: !localStream.getAudioTracks()[0].enabled,
    isVideoOff: !localStream.getVideoTracks()[0].enabled
  }
};

await setDoc(roomRef, {
createdBy: userId,
createdByUsername: username,
participants: participants,
isLocked: false,
createdAt: serverTimestamp()
});

roomSnapshotListener = onSnapshot(roomRef, async (snapshot) => {
const data = snapshot.data();
if (!snapshot.exists()) {
hangup();
showMessage("Room closed by host.", false);
return;
}
const remoteParticipantIds = Object.keys(data.participants).filter(id => id !== userId);
for (const remoteId of remoteParticipantIds) {
  if (!peerConnections[remoteId]) {
    const pc = setupPeerConnection(remoteId);
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    const offersCollection = collection(roomRef, `offers/${remoteId}/user-offers`);
    await addDoc(offersCollection, {
      offer: JSON.stringify({ sdp: offer.sdp, type: offer.type }),
      sender: userId
    });
    listenForAnswers(pc, remoteId);
    listenForCandidates(pc, remoteId);
  }
}
});

listenForChat(roomRef);
listenForParticipants();

showMessage(`Room created! Share this ID with your client: ${roomName}`);
createRoomBtn.disabled = true;
joinRoomBtn.disabled = true;
hangupBtn.disabled = false;
sendChatBtn.disabled = false;
};

// Join an existing room
const joinRoom = async () => {
if (!userId) {
showMessage("Authentication in progress. Please wait.", true);
return;
}
const roomId = roomIdInput.value;
if (!roomId) {
showMessage("Please enter a Room ID.", true);
return;
}

roomRef = doc(db, `artifacts/${appId}/public/data/video-rooms`, roomId);
const roomSnapshot = await getDoc(roomRef);

if (!roomSnapshot.exists()) {
showMessage("Room does not exist.", true);
return;
}

const roomData = roomSnapshot.data();
if (roomData.isLocked) {
  showMessage("This room is locked by the host.", true);
  return;
}

showMessage(`Joining room: ${roomId}`);

const startMuted = joinMutedCheckbox.checked;
if (startMuted) {
  localStream.getAudioTracks()[0].enabled = false;
  localStream.getVideoTracks()[0].enabled = false;
  toggleAudioBtn.textContent = "Unmute Audio";
  toggleVideoBtn.textContent = "Turn On Video";
} else {
  localStream.getAudioTracks()[0].enabled = true;
  localStream.getVideoTracks()[0].enabled = true;
  toggleAudioBtn.textContent = "Mute Audio";
  toggleVideoBtn.textContent = "Mute Video";
}


await updateDoc(roomRef, { [`participants.${userId}`]: {
  username: username,
  isMuted: !localStream.getAudioTracks()[0].enabled,
  isVideoOff: !localStream.getVideoTracks()[0].enabled
}});

roomSnapshotListener = onSnapshot(roomRef, async (snapshot) => {
const data = snapshot.data();
if (!snapshot.exists()) {
  hangup();
  showMessage('The host has closed the room.', true);
  return;
}
const remoteParticipantIds = Object.keys(data.participants).filter(id => id !== userId);
for (const remoteId of remoteParticipantIds) {
  if (!peerConnections[remoteId]) {
    const pc = setupPeerConnection(remoteId);
    listenForOffers(pc, remoteId);
    listenForCandidates(pc, remoteId);
  }
}
});

listenForChat(roomRef);
listenForParticipants();

showMessage(`Successfully joined room ${roomId}!`);
createRoomBtn.disabled = true;
joinRoomBtn.disabled = true;
hangupBtn.disabled = false;
sendChatBtn.disabled = false;
};

const listenForOffers = (pc, remoteId) => {
  const offersCollection = collection(roomRef, `offers/${userId}/user-offers`);
  onSnapshot(offersCollection, async (snapshot) => {
    snapshot.docChanges().forEach(async (change) => {
      if (change.type === 'added' && change.doc.data().sender === remoteId) {
        const offer = JSON.parse(change.doc.data().offer);
        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        const answersCollection = collection(roomRef, `answers/${remoteId}/user-answers`);
        await addDoc(answersCollection, {
          answer: JSON.stringify({ sdp: answer.sdp, type: answer.type }),
          sender: userId
        });
      }
    });
  });
}

const listenForAnswers = (pc, remoteId) => {
  const answersCollection = collection(roomRef, `answers/${userId}/user-answers`);
  onSnapshot(answersCollection, async (snapshot) => {
    snapshot.docChanges().forEach(async (change) => {
      if (change.type === 'added' && change.doc.data().sender === remoteId) {
        const answer = JSON.parse(change.doc.data().answer);
        if (!pc.currentRemoteDescription) {
          await pc.setRemoteDescription(new RTCSessionDescription(answer));
        }
      }
    });
  });
}

const listenForCandidates = (pc, remoteId) => {
  const candidatesCollection = collection(roomRef, `candidates/${userId}/user-candidates`);
  candidatesListeners[remoteId] = onSnapshot(candidatesCollection, async (snapshot) => {
    snapshot.docChanges().forEach(async (change) => {
      if (change.type === 'added' && change.doc.data().sender === remoteId) {
        const candidate = new RTCIceCandidate(JSON.parse(change.doc.data().candidate));
        await pc.addIceCandidate(candidate);
      }
    });
  });
}

// Hang up the call and clean up resources
const hangup = async () => {
if (localStream) {
localStream.getTracks().forEach(track => track.stop());
}
for (const pcId in peerConnections) {
  peerConnections[pcId].close();
}
peerConnections = {};
videoGrid.innerHTML = '';
isCreator = false;
isScreenSharing = false;
screenShareBtn.textContent = 'Screen Share';
toggleVideoBtn.disabled = false;

// Remove user from active users list
if (userId) {
  await deleteDoc(doc(db, `artifacts/${appId}/public/data/active-users`, userId));
}

if (roomRef) {
const roomSnapshot = await getDoc(roomRef);
const participants = roomSnapshot.data()?.participants || {};
if (participants[userId]) {
const newParticipants = { ...participants };
delete newParticipants[userId];
await updateDoc(roomRef, { participants: newParticipants });
if (Object.keys(newParticipants).length === 0) {
await deleteDoc(roomRef);
showMessage('Room has been automatically closed.', false);
} else {
showMessage(`${username} has left the room.`, false);
}
}
}

// Stop all listeners
if (roomSnapshotListener) roomSnapshotListener();
if (chatListener) chatListener();
if (roomsListener) roomsListener();
if (participantsListener) participantsListener();
if (activeUsersListener) activeUsersListener();
for (const listenerId in candidatesListeners) {
  candidatesListeners[listenerId]();
}
candidatesListeners = {};
roomSnapshotListener = null;
chatListener = null;
roomsListener = null;
participantsListener = null;
activeUsersListener = null;

// Reset UI state
roomIdInput.value = '';
hideMessage();
createRoomBtn.disabled = false;
joinRoomBtn.disabled = false;
hangupBtn.disabled = true;
toggleAudioBtn.disabled = true;
toggleVideoBtn.disabled = true;
fullScreenBtn.disabled = true;
sideBySideBtn.disabled = true;
lockRoomBtn.disabled = true;
videoQualitySelect.disabled = true;
screenShareBtn.disabled = true;
startRecordingBtn.disabled = true;
stopRecordingBtn.disabled = true;
sendChatBtn.disabled = true;
chatContainer.innerHTML = '';
participantsList.innerHTML = 'No participants in this room.';
};

const startScreenShare = async () => {
    if (isScreenSharing) {
        // Stop screen share and revert to camera
        isScreenSharing = false;
        screenShareBtn.textContent = 'Screen Share';
        toggleVideoBtn.disabled = false;
        
        const newStream = await getLocalStream();
        const newVideoTrack = newStream.getVideoTracks()[0];
        const newAudioTrack = newStream.getAudioTracks()[0];

        for (const pcId in peerConnections) {
          const pc = peerConnections[pcId];
          const videoSender = pc.getSenders().find(sender => sender.track.kind === 'video');
          if (videoSender) {
            videoSender.replaceTrack(newVideoTrack);
          }
          const audioSender = pc.getSenders().find(sender => sender.track.kind === 'audio');
          if (audioSender) {
            audioSender.replaceTrack(newAudioTrack);
          }
        }
        
    } else {
        // Start screen share
        isScreenSharing = true;
        screenShareBtn.textContent = 'Stop Sharing';
        toggleVideoBtn.disabled = true;

        const displayStream = await getDisplayStream();
        if (!displayStream) {
            isScreenSharing = false;
            screenShareBtn.textContent = 'Screen Share';
            toggleVideoBtn.disabled = false;
            return;
        }
        
        for (const pcId in peerConnections) {
          const pc = peerConnections[pcId];
          const videoSender = pc.getSenders().find(sender => sender.track.kind === 'video');
          if (videoSender) {
              videoSender.replaceTrack(localStream.getVideoTracks()[0]);
          }
          const audioSender = pc.getSenders().find(sender => sender.track.kind === 'audio');
          if (audioSender && localStream.getAudioTracks().length > 0) {
              audioSender.replaceTrack(localStream.getAudioTracks()[0]);
          } else if (audioSender) {
              audioSender.replaceTrack(null);
          }
        }
    }
};


// Toggle audio mute
const toggleAudio = async () => {
if (localStream) {
const audioTrack = localStream.getAudioTracks()[0];
const isMuted = !audioTrack.enabled;
audioTrack.enabled = isMuted; 
toggleAudioBtn.textContent = audioTrack.enabled ? "Mute Audio" : "Unmute Audio";
toggleAudioBtn.classList.toggle('btn-toggle-active', !audioTrack.enabled);
if (roomRef) {
  const participantRef = doc(collection(roomRef, 'participants'), userId);
  await updateDoc(doc(roomRef, 'participants', userId), { isMuted: !audioTrack.enabled });
}
}
};

// Toggle video mute
const toggleVideo = async () => {
if (localStream) {
const videoTrack = localStream.getVideoTracks()[0];
const isVideoOff = !videoTrack.enabled;
videoTrack.enabled = isVideoOff;
toggleVideoBtn.textContent = videoTrack.enabled ? "Mute Video" : "Unmute Video";
toggleVideoBtn.classList.toggle('btn-toggle-active', !videoTrack.enabled);
if (roomRef) {
  const participantRef = doc(collection(roomRef, 'participants'), userId);
  await updateDoc(doc(roomRef, 'participants', userId), { isVideoOff: !videoTrack.enabled });
}
}
};

// Toggle room lock status
const toggleRoomLock = async () => {
  if (isCreator && roomRef) {
    const roomSnapshot = await getDoc(roomRef);
    const isLocked = roomSnapshot.data()?.isLocked || false;
    await updateDoc(roomRef, { isLocked: !isLocked });
    lockRoomBtn.textContent = isLocked ? "Lock Room" : "Unlock Room";
    showMessage(isLocked ? "Room is now unlocked." : "Room is now locked.", false);
  }
};


// Start recording the remote video stream
const startRecording = () => {
if (!remoteVideo.srcObject) {
showMessage("No remote stream to record.", true);
return;
}
recordedChunks = [];
const stream = remoteVideo.srcObject;
mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });

mediaRecorder.ondataavailable = (e) => {
if (e.data.size > 0) {
recordedChunks.push(e.data);
}
};

mediaRecorder.onstop = () => {
const blob = new Blob(recordedChunks, { type: 'video/webm' });
const url = URL.createObjectURL(blob);
const a = document.getElementById('downloadRecording');
a.style.display = 'block';
a.href = url;
a.download = `conference-recording-${Date.now()}.webm`;
a.click();
URL.revokeObjectURL(url);
showMessage("Recording downloaded successfully!");
};

mediaRecorder.start();
showMessage("Recording started...");
startRecordingBtn.disabled = true;
stopRecordingBtn.disabled = false;
};

// Stop recording
const stopRecording = () => {
if (mediaRecorder && mediaRecorder.state !== 'inactive') {
mediaRecorder.stop();
showMessage("Recording stopped. Your download should start shortly.");
}
};

// Send a chat message
const sendMessage = async () => {
const message = chatInput.value.trim();
if (message === "" || !roomRef) return;

const chatMessagesRef = collection(roomRef, 'chat-messages');
await addDoc(chatMessagesRef, {
senderId: userId,
senderUsername: username,
text: message,
timestamp: serverTimestamp()
});
chatInput.value = '';
};

// Listen for new chat messages
const listenForChat = (roomDocRef) => {
if (chatListener) chatListener();
const chatMessagesRef = collection(roomDocRef, 'chat-messages');
chatListener = onSnapshot(chatMessagesRef, (snapshot) => {
snapshot.docChanges().forEach(change => {
if (change.type === 'added') {
const messageData = change.doc.data();
displayMessage(messageData);
}
});
}, (error) => {
console.error("Error listening to chat messages:", error);
});
};

// Display a chat message in the UI
const displayMessage = (messageData) => {
const messageDiv = document.createElement('div');
messageDiv.className = `message ${messageData.senderId === userId ? 'my-message' : 'other-message'}`;
messageDiv.innerHTML = `<span class="font-bold">${messageData.senderUsername}:</span> ${messageData.text}`;
chatContainer.appendChild(messageDiv);
chatContainer.scrollTop = chatContainer.scrollHeight;
};

// Listen for and display participants in the current room
const listenForParticipants = () => {
if (participantsListener) participantsListener();
participantsList.innerHTML = '';
participantsListener = onSnapshot(doc(db, `artifacts/${appId}/public/data/video-rooms/${roomIdInput.value}`), (snapshot) => {
const roomData = snapshot.data();
const participants = roomData?.participants || {};
const participantIds = Object.keys(participants);
if (participantIds.length > 0) {
participantsList.innerHTML = ''; // Clear previous list
participantIds.forEach(id => {
const participantData = participants[id];
const participantDiv = document.createElement('div');
participantDiv.className = 'flex items-center space-x-2 p-2 bg-[#3c3836] rounded-sm';
const participantName = participantData.username === username ? `${participantData.username} (You)` : participantData.username;
const audioIcon = participantData.isMuted ? '<i class="fas fa-microphone-slash"></i>' : '<i class="fas fa-microphone"></i>';
const videoIcon = participantData.isVideoOff ? '<i class="fas fa-video-slash"></i>' : '<i class="fas fa-video"></i>';
participantDiv.innerHTML = `
<i class="fas fa-user-circle text-lg"></i>
<span class="text-sm flex-1">${participantName}</span>
<span class="text-xs text-gray-400 space-x-2">${audioIcon} ${videoIcon}</span>
`;
participantsList.appendChild(participantDiv);
});
} else {
participantsList.innerHTML = 'No participants in this room.';
}
});
};


// Listen for active users on the website
const listenForActiveUsers = () => {
  if (activeUsersListener) activeUsersListener();
  activeUsersList.innerHTML = 'Loading users...';
  const activeUsersRef = collection(db, `artifacts/${appId}/public/data/active-users`);
  activeUsersListener = onSnapshot(activeUsersRef, (snapshot) => {
    activeUsersList.innerHTML = '';
    const users = snapshot.docs.map(doc => doc.data().username);
    if (users.length > 0) {
      users.forEach(user => {
        const userDiv = document.createElement('div');
        userDiv.className = 'flex items-center space-x-2 p-2 bg-[#3c3836] rounded-sm';
        userDiv.innerHTML = `
          <i class="fas fa-user-circle text-lg"></i>
          <span class="text-sm flex-1">${user}</span>
        `;
        activeUsersList.appendChild(userDiv);
      });
    } else {
      activeUsersList.innerHTML = '<p class="text-gray-500 text-sm">No active users.</p>';
    }
  });
};

// Toggle side-by-side view
const toggleSideBySide = () => {
  if (videoGrid.style.gridTemplateColumns === '50% 50%') {
    // Revert to default layout
    videoGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(300px, 1fr))';
  } else {
    // Set to side-by-side layout
    videoGrid.style.gridTemplateColumns = '50% 50%';
  }
};


// Set the user's username and show the main app
const setUsername = async () => {
const user = usernameInput.value.trim();
if (user) {
username = user;
usernamePrompt.style.display = 'none';
mainApp.style.display = 'grid';

const initialStream = await getLocalStream();

// Add user to active users list
const activeUsersRef = doc(db, `artifacts/${appId}/public/data/active-users`, userId);
await setDoc(activeUsersRef, { username: username, timestamp: serverTimestamp() });

} else {
showMessage("Please enter a username.", true);
}
};

// Handle modal actions
const handleModalAction = () => {
const action = confirmBtn.dataset.action;
const password = passwordInput.value;
passwordInput.value = '';
if (password !== 'max') {
showMessage('Incorrect password.', true);
passwordModal.classList.add('hidden');
return;
}
if (action === 'delete-all') {
deleteAllRooms();
} else if (action === 'create-room') {
createRoom();
}
passwordModal.classList.add('hidden');
};

// Delete all rooms with a password
const deleteAllRooms = async () => {
showMessage('Deleting all rooms...', false);
const roomsCollectionRef = collection(db, `artifacts/${appId}/public/data/video-rooms`);
try {
const roomsSnapshot = await getDocs(roomsCollectionRef);
if (roomsSnapshot.empty) {
showMessage('No rooms to delete.', false);
return;
}
const deletePromises = roomsSnapshot.docs.map(async (roomDoc) => {
const chatMessagesRef = collection(roomDoc.ref, 'chat-messages');
const chatSnapshot = await getDocs(chatMessagesRef);
const chatDeletePromises = chatSnapshot.docs.map(chatDoc => deleteDoc(chatDoc.ref));
await Promise.all(chatDeletePromises);
await deleteDoc(roomDoc.ref);
});
await Promise.all(deletePromises);
showMessage('All rooms have been deleted.', false);
} catch (error) {
console.error('Error deleting rooms:', error);
showMessage('Failed to delete rooms.', true);
}
};

// Event Listeners
window.onload = () => {
initFirebase();
};
submitUsernameBtn.addEventListener('click', setUsername);
usernameInput.addEventListener('keydown', (e) => {
if (e.key === 'Enter') setUsername();
});
createRoomBtn.addEventListener('click', () => {
passwordModalTitle.textContent = 'Create a New Room';
passwordModalText.textContent = 'Please enter the administrator password to create a room.';
confirmBtn.dataset.action = 'create-room';
passwordModal.classList.remove('hidden');
});
joinRoomBtn.addEventListener('click', joinRoom);
hangupBtn.addEventListener('click', hangup);
toggleAudioBtn.addEventListener('click', toggleAudio);
toggleVideoBtn.addEventListener('click', toggleVideo);
screenShareBtn.addEventListener('click', startScreenShare);
lockRoomBtn.addEventListener('click', toggleRoomLock);
startRecordingBtn.addEventListener('click', startRecording);
stopRecordingBtn.addEventListener('click', stopRecording);
sendChatBtn.addEventListener('click', sendMessage);
chatInput.addEventListener('keydown', (e) => {
if (e.key === 'Enter') sendMessage();
});
fullScreenBtn.addEventListener('click', () => {
if (videoGrid.requestFullscreen) {
  videoGrid.requestFullscreen();
}
});
sideBySideBtn.addEventListener('click', toggleSideBySide);
videoQualitySelect.addEventListener('change', async () => {
  if (localStream) {
    const newQuality = videoQualitySelect.value;
    const newConstraints = {
      audio: true,
      video: videoQualities[newQuality]
    };
    try {
      const newStream = await navigator.mediaDevices.getUserMedia(newConstraints);
      const newVideoTrack = newStream.getVideoTracks()[0];
      const oldVideoTrack = localStream.getVideoTracks()[0];
      if (oldVideoTrack) {
        oldVideoTrack.stop();
      }
      localStream.removeTrack(oldVideoTrack);
      localStream.addTrack(newVideoTrack);
      localVideo.srcObject = localStream;

      for (const pcId in peerConnections) {
        const sender = peerConnections[pcId].getSenders().find(s => s.track.kind === 'video');
        if (sender) {
          sender.replaceTrack(newVideoTrack);
        }
      }
      showMessage(`Video quality set to ${newQuality}.`, false);
    } catch (error) {
      console.error("Error setting video quality:", error);
      showMessage("Failed to change video quality. Your device may not support it.", true);
    }
  }
});
volumeControl.addEventListener('input', (e) => {
const videoElements = videoGrid.querySelectorAll('video');
videoElements.forEach(video => {
  if (!video.muted) {
    video.volume = e.target.value / 100;
  }
});
});
deleteAllRoomsBtn.addEventListener('click', () => {
passwordModalTitle.textContent = 'Enter Password';
passwordModalText.textContent = 'To delete all rooms, please enter the administrator password.';
confirmBtn.dataset.action = 'delete-all';
passwordModal.classList.remove('hidden');
});
confirmBtn.addEventListener('click', handleModalAction);
cancelBtn.addEventListener('click', () => {
passwordModal.classList.add('hidden');
passwordInput.value = '';
});

</script>
</body>
</html>
