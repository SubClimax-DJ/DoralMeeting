<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gruvbox Video Conferencing</title>
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-database-compat.js"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root {
      --bg: #282828; --bg1: #3c3836; --bg2: #504945; --bg3: #665c54; --bg4: #7c6f64;
      --fg: #fbf1c7; --fg1: #ebdbb2; --fg2: #d5c4a1; --fg3: #bdae93; --fg4: #a89984;
      --red: #fb4934; --green: #b8bb26; --yellow: #fabd2f; --blue: #83a598;
      --purple: #d3869b; --aqua: #8ec07c; --orange: #fe8019;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: var(--bg); color: var(--fg1); line-height: 1.6; }
    #root { max-width: 1200px; margin: 0 auto; padding: 1rem; display: flex; flex-direction: column; height: 100vh; }
    .header { background: var(--bg1); padding: 1rem; border-radius: 8px 8px 0 0; box-shadow: 0 2px 4px rgba(0,0,0,0.2); display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
    .header h1 { color: var(--aqua); font-size: 1.5rem; }
    .user-info { color: var(--fg3); font-size: 0.9rem; }
    .content { flex: 1; display: flex; flex-direction: column; background: var(--bg1); border-radius: 0 0 8px 8px; padding: 1.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1); overflow: hidden; }
    .form-group { margin-bottom: 1rem; }
    input { width: 100%; padding: 0.75rem; border: 1px solid var(--bg3); background: var(--bg2); color: var(--fg1); border-radius: 4px; font-size: 1rem; }
    input:focus { outline: none; border-color: var(--aqua); box-shadow: 0 0 0 2px rgba(142, 192, 124, 0.2); }
    button { padding: 0.75rem 1.5rem; margin: 0.25rem; border: none; background: var(--bg2); color: var(--fg1); font-size: 1rem; border-radius: 4px; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    button:hover { background: var(--green); color: var(--bg); transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
    button.danger { background: var(--red); border-color: var(--red); color: var(--bg); }
    button.danger:hover { background: var(--bg); color: var(--red); }
    .error { color: var(--red); margin-top: 0.5rem; font-size: 0.9rem; }
    .chat-container { display: flex; flex-direction: column; height: 100%; }
    .users-panel { width: 250px; background: var(--bg2); padding: 1rem; border-radius: 4px; margin-right: 1rem; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1); }
    .users-panel h3 { color: var(--aqua); margin-bottom: 1rem; font-size: 1.1rem; }
    .users { list-style: none; max-height: 300px; overflow-y: auto; }
    .users li { padding: 0.75rem; margin-bottom: 0.5rem; background: var(--bg3); border-radius: 4px; cursor: pointer; transition: background 0.2s; }
    .users li:hover { background: var(--green); color: var(--bg); }
    .chat { flex: 1; overflow-y: auto; background: var(--bg); padding: 1rem; border: 1px solid var(--bg3); border-radius: 4px; margin-bottom: 1rem; max-height: 400px; }
    .msg { margin-bottom: 0.75rem; padding: 0.5rem; background: var(--bg2); border-radius: 4px; border-left: 3px solid var(--aqua); }
    .msg strong { color: var(--aqua); }
    .msg time { color: var(--fg4); font-size: 0.8rem; margin-left: 0.5rem; }
    .input-group { display: flex; gap: 0.5rem; }
    .input-group input { flex: 1; }
    .video-container { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; background: var(--bg); border-radius: 8px; padding: 1rem; }
    .videos { display: flex; flex-direction: column; align-items: center; gap: 1rem; margin-bottom: 1rem; }
    .remote-video { width: 80%; max-width: 600px; height: 400px; background: #000; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
    .local-video { width: 150px; height: 120px; background: #000; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); position: absolute; top: 1rem; right: 1rem; }
    .controls { display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; }
    .hidden { display: none; }
    @media (max-width: 768px) { .users-panel { width: 100%; margin-right: 0; margin-bottom: 1rem; } #root { padding: 0.5rem; } .remote-video { width: 100%; height: 300px; } }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Firebase Config
    const firebaseConfig = {
      apiKey: "AIzaSyBluS1Dl9abDJjPPeOhvTCfP8J1kyIh6BQ",
      authDomain: "video-meeting-e73eb.firebaseapp.com",
      projectId: "video-meeting-e73eb",
      storageBucket: "video-meeting-e73eb.firebasestorage.app",
      messagingSenderId: "80496795033",
      appId: "1:80496795033:web:3ac35c631d76301f77c708",
      measurementId: "G-SFPQ0PJRPG"
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const rtdb = firebase.database();
    const appId = firebaseConfig.projectId;
    const adminEmail = 'admin@example.com';

    // Paths
    const basePath = ['artifacts', appId, 'public', 'data'];
    const usersColl = db.collection(...basePath, 'users');
    const callsColl = db.collection(...basePath, 'calls');

    function Login({ onLogin }) {
      const [username, setUsername] = useState('');
      const [password, setPassword] = useState('');
      const [error, setError] = useState('');

      const handleJoin = async () => {
        setError('');
        try {
          if (username.toLowerCase() === 'admin') {
            if (!password || password !== 'max') {
              setError('Invalid password for admin.');
              return;
            }
            await auth.signInWithEmailAndPassword(adminEmail, 'max');
            onLogin(true, 'Admin'); // isAdmin, nickname
          } else {
            await auth.signInAnonymously();
            const user = auth.currentUser;
            await usersColl.doc(user.uid).set({ nickname: username });
            onLogin(false, username);
          }
        } catch (e) {
          setError('Login failed. For admin, password is "max".');
        }
      };

      return (
        <div className="content">
          <div className="header">
            <h1>Gruvbox Video Conferencing</h1>
          </div>
          <div style={{ maxWidth: '400px', margin: '0 auto' }}>
            <div className="form-group">
              <input type="text" placeholder="Enter your username" value={username} onChange={e => setUsername(e.target.value)} onKeyPress={e => e.key === 'Enter' && handleJoin()} />
            </div>
            {username.toLowerCase() === 'admin' && (
              <div className="form-group">
                <input type="password" placeholder="Password" value={password} onChange={e => setPassword(e.target.value)} onKeyPress={e => e.key === 'Enter' && handleJoin()} />
              </div>
            )}
            <button onClick={handleJoin} style={{ width: '100%' }}>Join Lobby</button>
            {error && <p className="error">{error}</p>}
          </div>
        </div>
      );
    }

    function Lobby({ user, isAdmin, nickname, onInitiateCall, messages, users, onLogout }) {
      const [newMsg, setNewMsg] = useState('');
      const chatRef = useRef(null);

      const handleSend = () => {
        if (newMsg.trim()) {
          rtdb.ref('chat').push({ from: user.uid, msg: newMsg, time: Date.now() });
          setNewMsg('');
        }
      };

      useEffect(() => {
        if (chatRef.current) {
          chatRef.current.scrollTop = chatRef.current.scrollHeight;
        }
      }, [messages]);

      return (
        <div className="content chat-container">
          <div className="header">
            <h1>Waiting Lobby</h1>
            <div className="user-info">Welcome, {nickname} {isAdmin ? '(Admin)' : ''}</div>
          </div>
          <div style={{ display: 'flex', flex: 1, gap: '1rem' }}>
            {isAdmin && (
              <div className="users-panel">
                <h3>Active Users</h3>
                <ul className="users">
                  {Object.entries(users).filter(([uid]) => uid !== user.uid).map(([uid, u]) => (
                    <li key={uid} onClick={() => onInitiateCall(uid)}>{u.nickname}</li>
                  ))}
                </ul>
              </div>
            )}
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
              <div ref={chatRef} className="chat">
                {messages.map((m, i) => (
                  <div key={i} className="msg">
                    <strong>{users[m.from]?.nickname || 'Unknown'}:</strong> {m.msg}
                    <time>{new Date(m.time).toLocaleTimeString()}</time>
                  </div>
                ))}
              </div>
              <div className="input-group">
                <input type="text" value={newMsg} onChange={e => setNewMsg(e.target.value)} onKeyPress={e => e.key === 'Enter' && handleSend()} placeholder="Type a message..." />
                <button onClick={handleSend}>Send</button>
                <button className="danger" onClick={onLogout}>Logout</button>
              </div>
            </div>
          </div>
        </div>
      );
    }

    function Room({ user, currentCallId, onEndCall, onToggleMute, onToggleVideo, muted, videoEnabled }) {
      const localVideoRef = useRef();
      const remoteVideoRef = useRef();
      const pcRef = useRef();
      const [localStream, setLocalStream] = useState(null);
      const [remoteStream, setRemoteStream] = useState(null);
      const [isAdmin] = useState(() => auth.currentUser && auth.currentUser.email === adminEmail);
      const containerRef = useRef(null);

      useEffect(() => {
        if (!currentCallId) return;

        const callRef = callsColl.doc(currentCallId);
        const signalingColl = callRef.collection('signaling');
        pcRef.current = new RTCPeerConnection({
          iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });

        const pc = pcRef.current;
        pc.onicecandidate = e => {
          if (e.candidate) {
            signalingColl.add({ type: 'ice', candidate: e.candidate, from: user.uid });
          }
        };
        pc.ontrack = e => setRemoteStream(e.streams[0]);

        const unsubscribe = callRef.onSnapshot(async doc => {
          if (!doc.exists || doc.data().status === 'ended') {
            onEndCall();
            return;
          }
          if (!doc.data().participants.includes(user.uid)) {
            onEndCall();
            return;
          }
        });

        const unsubSignaling = signalingColl.onSnapshot(snapshot => {
          snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
              const msg = change.doc.data();
              if (msg.from === user.uid) return;
              handleSignalingMessage(msg);
            }
          });
        });

        const handleSignalingMessage = async (msg) => {
          try {
            switch (msg.type) {
              case 'offer':
                await pc.setRemoteDescription(new RTCSessionDescription(msg));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                signalingColl.add({ type: 'answer', ...answer, from: user.uid });
                break;
              case 'answer':
                await pc.setRemoteDescription(new RTCSessionDescription(msg));
                break;
              case 'ice':
                await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
                break;
            }
          } catch (e) { console.error(e); }
        };

        // Get local stream
        navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then(stream => {
          setLocalStream(stream);
          localVideoRef.current.srcObject = stream;
          stream.getTracks().forEach(track => pc.addTrack(track, stream));
          if (isAdmin) {
            pc.createOffer().then(offer => {
              pc.setLocalDescription(offer).then(() => {
                signalingColl.add({ type: 'offer', ...offer, from: user.uid });
              });
            });
          }
        }).catch(console.error);

        return () => {
          unsubscribe();
          unsubSignaling();
          if (pc) pc.close();
          if (localStream) localStream.getTracks().forEach(track => track.stop());
        };
      }, [currentCallId, isAdmin]);

      useEffect(() => {
        if (localVideoRef.current && localStream) {
          localVideoRef.current.srcObject = localStream;
        }
        if (remoteVideoRef.current && remoteStream) {
          remoteVideoRef.current.srcObject = remoteStream;
        }
      }, [localStream, remoteStream]);

      const toggleMute = () => {
        if (localStream) {
          const audioTrack = localStream.getAudioTracks()[0];
          if (audioTrack) audioTrack.enabled = !muted;
        }
        onToggleMute();
      };

      const toggleVideo = () => {
        if (localStream) {
          const videoTrack = localStream.getVideoTracks()[0];
          if (videoTrack) videoTrack.enabled = !videoEnabled;
        }
        onToggleVideo();
      };

      const endCall = async () => {
        const callRef = callsColl.doc(currentCallId);
        await callRef.update({ status: 'ended' });
        const userRef = usersColl.doc(user.uid);
        await userRef.update({ pendingCall: null });
        onEndCall();
      };

      if (!currentCallId) return null;

      return (
        <div ref={containerRef} className="content video-container">
          <div className="header">
            <h1>Video Conference</h1>
            <div className="user-info">In call...</div>
          </div>
          <div className="videos" style={{ position: 'relative' }}>
            <video ref={remoteVideoRef} className="remote-video" autoPlay playsInline />
            <video ref={localVideoRef} className="local-video" autoPlay playsInline muted />
          </div>
          <div className="controls">
            <button onClick={toggleMute}>{muted ? 'Unmute' : 'Mute'}</button>
            <button onClick={toggleVideo}>{videoEnabled ? 'Video Off' : 'Video On'}</button>
            <button className="danger" onClick={endCall}>End Call</button>
          </div>
        </div>
      );
    }

    function App() {
      const [user, setUser] = useState(null);
      const [isAdmin, setIsAdmin] = useState(false);
      const [nickname, setNickname] = useState('');
      const [page, setPage] = useState('login');
      const [currentCallId, setCurrentCallId] = useState(null);
      const [messages, setMessages] = useState([]);
      const [users, setUsers] = useState({});
      const [muted, setMuted] = useState(false);
      const [videoEnabled, setVideoEnabled] = useState(true);

      useEffect(() => {
        const unsubscribe = auth.onAuthStateChanged(u => setUser(u));
        return unsubscribe;
      }, []);

      useEffect(() => {
        if (!user) {
          setPage('login');
          return;
        }

        // Set presence
        const statusRef = rtdb.ref(`status/${user.uid}`);
        if (nickname) {
          statusRef.set({ online: true, nickname });
        }
        statusRef.onDisconnect().set({ online: false });

        // Listen to chat
        const chatUnsub = rtdb.ref('chat').on('value', snap => {
          const data = snap.val();
          const msgs = data ? Object.entries(data).map(([k, v]) => ({ id: k, ...v })).sort((a, b) => a.time - b.time) : [];
          setMessages(msgs);
        });

        // Listen to users
        const usersUnsub = rtdb.ref('status').on('value', snap => {
          const data = snap.val() || {};
          const us = {};
          for (let uid in data) {
            if (data[uid].online) us[uid] = data[uid];
          }
          setUsers(us);
        });

        // Listen to pending call
        const userRef = usersColl.doc(user.uid);
        const unsubUser = userRef.onSnapshot(doc => {
          const data = doc.data();
          if (data?.pendingCall && !currentCallId) {
            setCurrentCallId(data.pendingCall);
            setPage('room');
          }
        });

        setPage('lobby');
        return () => {
          if (chatUnsub) chatUnsub();
          if (usersUnsub) usersUnsub();
          if (unsubUser) unsubUser();
        };
      }, [user, nickname, currentCallId]);

      const onLogin = (admin, nick) => {
        setIsAdmin(admin);
        setNickname(nick);
      };

      const initiateCall = async (targetUid) => {
        const callId = `call-${Date.now()}`;
        const callRef = callsColl.doc(callId);
        await callRef.set({ participants: [user.uid, targetUid], created: Date.now(), status: 'active' });
        const targetRef = usersColl.doc(targetUid);
        await targetRef.update({ pendingCall: callId });
        setCurrentCallId(callId);
        setPage('room');
      };

      const onEndCall = () => {
        setCurrentCallId(null);
        setPage('lobby');
        if (user) {
          usersColl.doc(user.uid).update({ pendingCall: null }).catch(console.error);
        }
      };

      const onLogout = () => {
        auth.signOut().then(() => {
          setUser(null);
          setPage('login');
          setNickname('');
        });
      };

      const onToggleMute = () => setMuted(!muted);
      const onToggleVideo = () => setVideoEnabled(!videoEnabled);

      if (page === 'login') return <Login onLogin={onLogin} />;
      if (page === 'lobby') return <Lobby user={user} isAdmin={isAdmin} nickname={nickname} onInitiateCall={initiateCall} messages={messages} users={users} onLogout={onLogout} />;
      if (page === 'room') return <Room user={user} currentCallId={currentCallId} onEndCall={onEndCall} onToggleMute={onToggleMute} onToggleVideo={onToggleVideo} muted={muted} videoEnabled={videoEnabled} />;

      return <div className="content"><div className="header"><h1>Loading...</h1></div></div>;
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
