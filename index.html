<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doral Video Conference</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600&family=Lato:wght@400;700&display=swap');
        body {
            font-family: 'Lato', sans-serif;
            background-color: #282828;
            color: #ebdbb2;
        }
        .header {
            background-color: #1d2021;
            color: #ebdbb2;
        }
        .container-card {
            background-color: #32302f;
            border-radius: 0.5rem;
            padding: 2rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        .btn-primary {
            @apply px-6 py-3 font-semibold rounded-sm transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2;
            background-color: #458588;
            color: #ebdbb2;
        }
        .btn-danger {
            @apply px-6 py-3 font-semibold rounded-sm transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2;
            background-color: #fb4934;
            color: #ebdbb2;
        }
        .btn-toggle {
            @apply px-4 py-2 font-semibold rounded-sm transition duration-300 focus:outline-none;
            background-color: #504945;
            color: #ebdbb2;
        }
        .btn-toggle-active {
            @apply px-4 py-2 font-semibold rounded-sm transition duration-300 focus:outline-none;
            background-color: #b8bb26;
            color: #1d2021;
        }
        .input-field {
            @apply w-full px-4 py-3 rounded-sm border border-gray-600 focus:outline-none focus:ring-2 transition duration-200;
            background-color: #32302f;
            color: #ebdbb2;
        }
        .video-container {
            position: relative;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            background-color: #1d2021;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            width: 100%;
            min-height: 400px;
        }
        .video-grid-item {
            position: relative;
            background-color: #1d2021;
            border-radius: 0.5rem;
            overflow: hidden;
            transition: border 0.3s ease;
        }
        .video-grid-item.speaking {
            border: 4px solid #b8bb26;
        }
        .video-grid-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .video-label {
            position: absolute;
            bottom: 0.5rem;
            left: 0.5rem;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
        }
        .video-status-icons {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            display: flex;
            gap: 0.5rem;
            color: #ebdbb2;
        }
        .chat-container {
            background-color: #3c3836;
            border: 1px solid #504945;
            border-radius: 0.5rem;
            height: 300px;
            overflow-y: auto;
            display: flex;
            flex-direction: column-reverse;
        }
        .message {
            padding: 0.5rem 1rem;
            margin: 0.5rem;
            border-radius: 0.75rem;
            max-width: 85%;
            word-wrap: break-word;
        }
        .my-message {
            background-color: #458588;
            color: #ebdbb2;
            align-self: flex-end;
        }
        .other-message {
            background-color: #665c54;
            color: #ebdbb2;
            align-self: flex-start;
        }
        .modal {
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: #32302f;
            padding: 20px;
            border: 1px solid #888;
            width: 90%;
            max-width: 800px;
            position: relative;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.3s;
            border-radius: 0.5rem;
        }
        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-btn:hover,
        .close-btn:focus {
            color: #ebdbb2;
            text-decoration: none;
            cursor: pointer;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #whiteboard-tools {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            background-color: #3c3836;
            padding: 1rem;
            border-radius: 0.5rem;
            align-items: center;
        }
        .color-picker-btn {
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            border: 2px solid transparent;
        }
        .color-picker-btn.active {
            border-color: #ebdbb2;
        }
    </style>
</head>
<body class="flex flex-col items-center min-h-screen p-4">
    <header class="header w-full py-4 mb-8 flex flex-col sm:flex-row items-center justify-between px-6 shadow-md">
        <div class="flex items-center">
            <img src="https://content.enrollmystudent.org/contact_school_logo/school_logo_1655490559.jpg" alt="School Logo" class="h-12 mr-4">
            <h1 class="text-3xl sm:text-4xl font-semibold font-['Crimson_Pro']">
                Doral Video Conference
            </h1>
            <div id="recording-indicator" class="hidden ml-4 px-2 py-1 bg-red-600 text-white text-xs font-bold rounded-sm animate-pulse">REC</div>
        </div>
        <div class="text-sm mt-2 sm:mt-0 font-light" id="auth-status">Authenticating...</div>
    </header>

    <main class="w-full max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-3 gap-8">
        <!-- Initial Username Prompt -->
        <div id="usernamePrompt" class="md:col-span-3 flex flex-col items-center justify-center p-8 bg-[#32302f] rounded-lg shadow-xl">
            <h2 class="text-2xl font-bold font-['Crimson_Pro'] mb-4">Enter Your Username</h2>
            <p class="text-sm text-gray-400 mb-6 text-center">Your username will be visible to other participants in the chat.</p>
            <input type="text" id="usernameInput" placeholder="e.g., JaneDoe" class="input-field max-w-sm mb-4" />
            <button id="submitUsernameBtn" class="btn-primary max-w-xs w-full">Start</button>
        </div>
        
        <!-- Device Selection (hidden initially) -->
        <div id="deviceSelection" class="md:col-span-3 hidden flex flex-col items-center justify-center p-8 bg-[#32302f] rounded-lg shadow-xl">
            <h2 class="text-2xl font-bold font-['Crimson_Pro'] mb-4">Select Devices</h2>
            <div class="w-full max-w-sm space-y-4">
                <div>
                    <label for="cameraSelect" class="block text-sm font-semibold mb-2">Camera</label>
                    <select id="cameraSelect" class="input-field"></select>
                </div>
                <div>
                    <label for="micSelect" class="block text-sm font-semibold mb-2">Microphone</label>
                    <select id="micSelect" class="input-field"></select>
                </div>
            </div>
            <button id="startCallBtn" class="btn-primary max-w-xs w-full mt-6">Continue</button>
        </div>

        <!-- Main App Content (hidden initially) -->
        <div id="mainApp" class="md:col-span-3 hidden grid grid-cols-1 md:grid-cols-3 gap-8">
            <!-- Room Management & Chat (now on the left) -->
            <div class="md:col-span-1 space-y-8">
                <div class="container-card">
                    <h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Room Management</h2>
                    <div class="flex flex-col space-y-4">
                        <div class="flex space-x-2">
                            <input type="text" id="roomIdInput" placeholder="Enter Room ID" class="input-field flex-1" />
                            <button id="joinRoomBtn" class="btn-primary">Join</button>
                        </div>
                        <button id="createRoomBtn" class="btn-primary">Create New Room</button>
                        <button id="deleteAllRoomsBtn" class="btn-danger">Delete All Rooms</button>
                    </div>
                </div>
    
                <div class="container-card">
                    <h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Active Rooms</h2>
                    <div id="activeRoomsList" class="space-y-2">
                        <p class="text-gray-500 text-sm">Loading rooms...</p>
                    </div>
                </div>
                
                <div id="waitingRoomList" class="container-card hidden">
                    <h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Waiting Room</h2>
                    <p class="text-gray-400 text-sm">No one is waiting.</p>
                </div>
                
                <div id="whiteboard-host-controls" class="container-card hidden">
                    <h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Whiteboard</h2>
                    <button id="toggleWhiteboardBtn" class="btn-primary w-full">Start Whiteboard</button>
                </div>

                <div class="container-card" id="participantsList" style="display: none;">
                    <h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Participants</h2>
                    <p class="text-gray-400 text-sm">No other participants.</p>
                </div>
    
                <div class="container-card">
                    <h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Chat</h2>
                    <div class="chat-container mb-4" id="chatContainer"></div>
                    <div class="flex space-x-2">
                        <input type="text" id="chatInput" placeholder="Send a message..." class="input-field flex-1" />
                        <button id="sendChatBtn" class="btn-primary">Send</button>
                    </div>
                </div>
                
                <div id="file-sharing" class="container-card">
                    <h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Share Files</h2>
                    <input type="file" id="fileInput" class="hidden" />
                    <button id="uploadFileBtn" class="btn-primary w-full">Upload File</button>
                    <p id="fileNameDisplay" class="text-xs text-gray-400 mt-2"></p>
                </div>
            </div>

            <!-- Video and Controls (now on the right) -->
            <div class="md:col-span-2 container-card">
                <h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Video Feeds</h2>
                <div id="videoFeeds" class="video-grid">
                    <!-- Dynamic video elements will be added here -->
                </div>
                <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 items-center justify-center mt-4">
                    <button id="toggleAudioBtn" class="btn-toggle" disabled><i class="fas fa-microphone"></i> Mute Audio</button>
                    <button id="toggleVideoBtn" class="btn-toggle" disabled><i class="fas fa-video"></i> Mute Video</button>
                    <button id="screenShareBtn" class="btn-toggle" disabled><i class="fas fa-desktop"></i> Share Screen</button>
                    <button id="hangupBtn" class="btn-danger flex-1" disabled>Hang Up</button>
                    <button id="startRecordingBtn" class="btn-primary" disabled>Start Recording</button>
                    <button id="raiseHandBtn" class="btn-primary hidden">Raise Hand</button>
                    <button id="resetLayoutBtn" class="btn-primary hidden">Reset Layout</button>
                </div>
            </div>
        </div>
    </main>
    <canvas id="whiteboardCanvas" class="hidden absolute top-0 left-0 w-full h-full z-20"></canvas>
    <div id="whiteboard-tools" class="hidden fixed bottom-4 right-4 z-30">
        <button id="whiteboardClearBtn" class="btn-danger p-3"><i class="fas fa-trash"></i></button>
        <input type="color" id="whiteboardColorPicker" value="#ebdbb2" class="p-0 border-0 bg-transparent cursor-pointer h-10 w-10">
        <select id="whiteboardLineSize" class="bg-gray-700 text-ebdbb2 p-2 rounded-sm text-sm">
            <option value="2">2px</option>
            <option value="5">5px</option>
            <option value="10">10px</option>
        </select>
    </div>
    <canvas id="recordingCanvas" style="display:none;"></canvas>
    <div id="documentViewer" class="modal hidden">
        <div class="modal-content">
            <span class="close-btn" id="closeDocumentViewer">&times;</span>
            <div id="documentViewerContent" class="mt-4" style="width:100%; height:80vh;"></div>
        </div>
    </div>
    <div id="status-message" class="fixed bottom-4 left-1/2 -translate-x-1/2 p-4 rounded-lg text-sm text-center text-gray-700 bg-gray-100 hidden"></div>
    <a id="downloadRecording" style="display: none;"></a>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="modal hidden">
        <div class="modal-content text-center">
            <h3 class="text-xl font-bold mb-4">Confirm Deletion</h3>
            <p class="mb-6">Are you sure you want to delete all active and inactive rooms? This action cannot be undone.</p>
            <div class="flex justify-center space-x-4">
                <button id="confirmDeleteBtn" class="btn-danger">Delete All</button>
                <button id="cancelDeleteBtn" class="btn-toggle">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Font Awesome Icons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/js/all.min.js"></script>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, setLogLevel, serverTimestamp, getFirestore as db, getDoc as doc, getDocs as docs, deleteDoc as deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        // User's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBluS1Dl9abDJjPPeOhvTCfP8J1kyIh6BQ",
            authDomain: "video-meeting-e73eb.firebaseapp.com",
            projectId: "video-meeting-e73eb",
            storageBucket: "video-meeting-e73eb.firebasestorage.app",
            messagingSenderId: "80496795033",
            appId: "1:80496795033:web:3ac35c631d76301f77c708",
            measurementId: "G-SFPQ0PJRPG"
        };
        
        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : firebaseConfig.appId;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // UI Elements
        const usernamePrompt = document.getElementById('usernamePrompt');
        const mainApp = document.getElementById('mainApp');
        const usernameInput = document.getElementById('usernameInput');
        const submitUsernameBtn = document.getElementById('submitUsernameBtn');
        const deviceSelection = document.getElementById('deviceSelection');
        const cameraSelect = document.getElementById('cameraSelect');
        const micSelect = document.getElementById('micSelect');
        const startCallBtn = document.getElementById('startCallBtn');
        
        const videoFeeds = document.getElementById('videoFeeds');
        const roomIdInput = document.getElementById('roomIdInput');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const hangupBtn = document.getElementById('hangupBtn');
        const toggleAudioBtn = document.getElementById('toggleAudioBtn');
        const toggleVideoBtn = document.getElementById('toggleVideoBtn');
        const screenShareBtn = document.getElementById('screenShareBtn');
        const startRecordingBtn = document.getElementById('startRecordingBtn');
        const recordingIndicator = document.getElementById('recording-indicator');
        const downloadRecording = document.getElementById('downloadRecording');
        const chatInput = document.getElementById('chatInput');
        const sendChatBtn = document.getElementById('sendChatBtn');
        const chatContainer = document.getElementById('chatContainer');
        const statusMessage = document.getElementById('status-message');
        const authStatus = document.getElementById('auth-status');
        const activeRoomsList = document.getElementById('activeRoomsList');
        const participantsList = document.getElementById('participantsList');
        const waitingRoomList = document.getElementById('waitingRoomList');
        const whiteboardCanvas = document.getElementById('whiteboardCanvas');
        const whiteboardHostControls = document.getElementById('whiteboard-host-controls');
        const toggleWhiteboardBtn = document.getElementById('toggleWhiteboardBtn');
        const raiseHandBtn = document.getElementById('raiseHandBtn');
        const fileInput = document.getElementById('fileInput');
        const uploadFileBtn = document.getElementById('uploadFileBtn');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const documentViewer = document.getElementById('documentViewer');
        const closeDocumentViewerBtn = document.getElementById('closeDocumentViewer');
        const documentViewerContent = document.getElementById('documentViewerContent');
        const recordingCanvas = document.getElementById('recordingCanvas');
        const canvasCtx = recordingCanvas.getContext('2d');
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const whiteboardTools = document.getElementById('whiteboard-tools');
        const whiteboardColorPicker = document.getElementById('whiteboardColorPicker');
        const whiteboardLineSize = document.getElementById('whiteboardLineSize');
        const whiteboardClearBtn = document.getElementById('whiteboardClearBtn');
        const resetLayoutBtn = document.getElementById('resetLayoutBtn');
        const deleteAllRoomsBtn = document.getElementById('deleteAllRoomsBtn');
        const confirmationModal = document.getElementById('confirmationModal');
        const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
        const cancelDeleteBtn = document.getElementById('cancelDeleteBtn');

        // Firestore and Auth instances
        let app, db, auth, storage;
        let userId;

        // User-specific variables
        let username;
        let isCreator = false;
        let isRecording = false;
        let isHandRaised = false;

        // WebRTC variables
        let peerConnections = {}; 
        let localStream = null;
        let screenShareStream = null;
        let roomRef = null;
        let roomSnapshotListener = null;
        let roomsListener = null;
        let participantsListener = null;
        let userStatusListener = null;
        let whiteboardListener = null;
        let documentShareListener = null;
        let remoteMuteListener = null;
        let activeSpeakerId = null;
        let remoteStreams = {};

        // Recording variables
        let mediaRecorder;
        let recordedChunks = [];
        let drawingInterval;

        // Whiteboard variables
        let isWhiteboardActive = false;
        let whiteboardCtx;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentWhiteboardColor = '#ebdbb2';
        let currentWhiteboardSize = 2;

        // WebRTC STUN servers
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
            ]
        };

        const showMessage = (msg, isError = false) => {
            statusMessage.textContent = msg;
            statusMessage.style.display = 'block';
            statusMessage.className = `fixed bottom-4 left-1/2 -translate-x-1/2 p-4 rounded-lg text-sm text-center transition-all duration-300 transform animate-fade-in ${isError ? 'text-red-700 bg-red-100' : 'text-gray-700 bg-gray-100'}`;
        };

        const hideMessage = () => {
            statusMessage.style.display = 'none';
        };

        const updateButtonState = () => {
            if (localStream && localStream.getAudioTracks().length > 0) {
                const audioTrack = localStream.getAudioTracks()[0];
                const isAudioMuted = !audioTrack.enabled;
                toggleAudioBtn.textContent = isAudioMuted ? "Unmute Audio" : "Mute Audio";
                toggleAudioBtn.classList.toggle('btn-toggle-active', !isAudioMuted);
            }
            toggleAudioBtn.disabled = !localStream;

            if (localStream && localStream.getVideoTracks().length > 0) {
                const videoTrack = localStream.getVideoTracks()[0];
                const isVideoOff = !videoTrack.enabled;
                toggleVideoBtn.textContent = isVideoOff ? "Turn On Video" : "Mute Video";
                toggleVideoBtn.classList.toggle('btn-toggle-active', !isVideoOff);
            }
            toggleVideoBtn.disabled = !localStream;
            screenShareBtn.disabled = !localStream;
            startRecordingBtn.disabled = !localStream || !isCreator;
        };

        const getDevices = async () => {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                cameraSelect.innerHTML = '';
                micSelect.innerHTML = '';

                let hasCameras = false;
                let hasMics = false;
                
                devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `${device.kind === 'videoinput' ? 'Camera' : 'Microphone'} ${device.deviceId.substring(0, 5)}...`;
                    if (device.kind === 'videoinput') {
                        cameraSelect.appendChild(option);
                        hasCameras = true;
                    } else if (device.kind === 'audioinput') {
                        micSelect.appendChild(option);
                        hasMics = true;
                    }
                });

                if (!hasCameras) {
                    cameraSelect.innerHTML = '<option>No cameras found</option>';
                    cameraSelect.disabled = true;
                }
                if (!hasMics) {
                    micSelect.innerHTML = '<option>No microphones found</option>';
                    micSelect.disabled = true;
                }
            } catch (error) {
                console.error("Error getting devices:", error);
                showMessage("Could not access devices. Please check permissions.", true);
            }
        };

        const getLocalStream = async () => {
            try {
                const videoDeviceId = cameraSelect.value;
                const audioDeviceId = micSelect.value;
                const constraints = {
                    video: videoDeviceId ? { deviceId: { exact: videoDeviceId } } : false,
                    audio: audioDeviceId ? { deviceId: { exact: audioDeviceId } } : false
                };
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                return localStream;
            } catch (error) {
                console.error("Error getting user media:", error);
                showMessage("Could not access camera/microphone. Permissions may have been denied.", true);
                return null;
            }
        };

        const initFirebase = async () => {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                storage = getStorage(app);
                auth = getAuth(app);
                setLogLevel('debug');

                const handleAuth = async () => {
                    try {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token !== null) {
                            await signInWithCustomToken(auth, __initialAuthToken);
                            console.log("Signed in with custom token.");
                        } else {
                            await signInAnonymously(auth);
                            console.log("Signed in anonymously.");
                        }
                    } catch (error) {
                        console.error("Authentication failed. Falling back to anonymous sign-in.", error);
                        await signInAnonymously(auth);
                    }
                };

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        authStatus.textContent = `User ID: ${userId}`;
                        createRoomBtn.disabled = false;
                        joinRoomBtn.disabled = false;
                        listenForRooms();
                    } else {
                        authStatus.textContent = 'Authenticating...';
                        await handleAuth();
                    }
                });
            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                showMessage(`Firebase initialization failed: ${error.message}`, true);
            }
        };

        const setupPeerConnection = (targetUserId) => {
            const peerConnection = new RTCPeerConnection(configuration);

            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            peerConnection.onicecandidate = async (event) => {
                if (event.candidate) {
                    const candidatesCollectionRef = collection(roomRef, `candidates-${targetUserId}`);
                    await addDoc(candidatesCollectionRef, { candidate: JSON.stringify(event.candidate.toJSON()), sender: userId });
                }
            };
            
            peerConnection.ontrack = (event) => {
                const videoElement = document.getElementById(`video-${targetUserId}`);
                if (videoElement) {
                    videoElement.srcObject = event.streams[0];
                    remoteStreams[targetUserId] = event.streams[0];
                    if (event.streams[0].getAudioTracks().length > 0) {
                        setupAudioDetection(event.streams[0], targetUserId);
                    }
                }
            };
            
            peerConnections[targetUserId] = peerConnection;
            return peerConnection;
        };

        const setupAudioDetection = (stream, id) => {
            const source = audioCtx.createMediaStreamSource(stream);
            const analyser = audioCtx.createAnalyser();
            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            source.connect(analyser);

            const checkVolume = () => {
                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((acc, val) => acc + val, 0) / dataArray.length;
                const isSpeaking = average > 40; 

                const videoContainer = document.getElementById(`video-container-${id}`);
                if (videoContainer) {
                    videoContainer.classList.toggle('speaking', isSpeaking);
                }
                
                if (isSpeaking && id !== activeSpeakerId) {
                    activeSpeakerId = id;
                } else if (!isSpeaking && id === activeSpeakerId) {
                    const activeStreams = Object.keys(remoteStreams).filter(k => k !== userId).map(k => remoteStreams[k]);
                    const newSpeaker = activeStreams.find(s => {
                         const analyser = audioCtx.createAnalyser();
                         const dataArray = new Uint8Array(analyser.frequencyBinCount);
                         audioCtx.createMediaStreamSource(s).connect(analyser);
                         analyser.getByteFrequencyData(dataArray);
                         const avg = dataArray.reduce((acc, val) => acc + val, 0) / dataArray.length;
                         return avg > 40;
                    });
                    activeSpeakerId = newSpeaker ? Object.keys(remoteStreams).find(k => remoteStreams[k] === newSpeaker) : null;
                }

                if (stream.active) {
                    requestAnimationFrame(checkVolume);
                }
            };
            requestAnimationFrame(checkVolume);
        };
        
        const createVideoElement = (id, label) => {
            const videoContainer = document.createElement('div');
            videoContainer.className = 'video-grid-item';
            videoContainer.id = `video-container-${id}`;
            
            const video = document.createElement('video');
            video.id = `video-${id}`;
            video.autoplay = true;
            video.playsinline = true;
            if (id === userId) {
                video.muted = true;
            }

            const labelDiv = document.createElement('div');
            labelDiv.className = 'video-label';
            labelDiv.textContent = label;
            
            const statusIcons = document.createElement('div');
            statusIcons.className = 'video-status-icons';
            statusIcons.innerHTML = `
                <i id="audio-icon-${id}" class="fas fa-microphone"></i>
                <i id="video-icon-${id}" class="fas fa-video"></i>
                <i id="hand-icon-${id}" class="fas fa-hand-paper hidden"></i>
            `;

            videoContainer.appendChild(video);
            videoContainer.appendChild(labelDiv);
            videoContainer.appendChild(statusIcons);
            videoFeeds.appendChild(videoContainer);
        };

        const listenForRooms = () => {
            if (roomsListener) {
                roomsListener();
            }
            const roomsCollectionRef = collection(db, `artifacts/${appId}/public/data/video-rooms`);
            roomsListener = onSnapshot(roomsCollectionRef, (snapshot) => {
                activeRoomsList.innerHTML = '';
                if (snapshot.empty) {
                    activeRoomsList.innerHTML = '<p class="text-gray-500 text-sm">No active rooms.</p>';
                } else {
                    snapshot.forEach(doc => {
                        const roomData = doc.data();
                        const roomName = doc.id;
                        const roomDiv = document.createElement('div');
                        roomDiv.className = 'flex items-center justify-between p-2 bg-[#3c3836] rounded-sm hover:bg-[#504945] transition duration-150 cursor-pointer';
                        roomDiv.innerHTML = `
                            <div class="flex flex-col">
                                <span class="font-semibold">${roomName}</span>
                                <span class="text-xs text-gray-400">Created by: ${roomData.createdByUsername}</span>
                            </div>
                            <button data-room-id="${roomName}" class="join-room-btn px-3 py-1 text-sm rounded-sm bg-blue-600 text-white hover:bg-blue-700">Join</button>
                        `;
                        activeRoomsList.appendChild(roomDiv);
                    });
                    document.querySelectorAll('.join-room-btn').forEach(button => {
                        button.addEventListener('click', (e) => {
                            roomIdInput.value = e.target.dataset.roomId;
                            joinRoom();
                        });
                    });
                }
            });
        };

        const createRoom = async () => {
            isCreator = true;
            
            const roomName = `room-${Math.random().toString(36).substring(2, 9)}`;
            roomIdInput.value = roomName;
            roomRef = doc(db, `artifacts/${appId}/public/data/video-rooms`, roomName);

            showMessage("Creating room...");

            createVideoElement(userId, username);
            const localVideoElement = document.getElementById(`video-${userId}`);
            localVideoElement.srcObject = localStream;
            hangupBtn.disabled = false;
            startRecordingBtn.disabled = false;
            whiteboardHostControls.classList.remove('hidden');
            raiseHandBtn.classList.add('hidden');
            resetLayoutBtn.classList.remove('hidden');
            whiteboardTools.classList.remove('hidden');

            if (localStream.getAudioTracks().length > 0) {
                setupAudioDetection(localStream, userId);
            }
            
            await setDoc(roomRef, { 
                createdBy: userId, 
                createdByUsername: username,
                participants: { [userId]: username },
                status: { [userId]: { isMuted: false, isCamOff: false, isHandRaised: false } },
                whiteboard: { isActive: false, data: [] },
                sharedFiles: {},
                waiting: {},
                spotlightedUser: null
            });

            roomSnapshotListener = onSnapshot(roomRef, async (snapshot) => {
                const data = snapshot.data();
                if (!snapshot.exists()) {
                    hangup();
                    showMessage("Room closed by host.", false);
                    return;
                }
                const newParticipants = data.participants;
                const spotlightedUser = data.spotlightedUser;
                const currentParticipants = Array.from(videoFeeds.children).map(el => el.id.replace('video-container-', '')).filter(id => id !== 'undefined');

                // Remove participants who have left
                currentParticipants.forEach(id => {
                    if (!newParticipants[id]) {
                        const videoContainer = document.getElementById(`video-container-${id}`);
                        if (videoContainer) videoContainer.remove();
                        if (peerConnections[id]) peerConnections[id].close();
                        delete peerConnections[id];
                        delete remoteStreams[id];
                    }
                });

                // Add new participants
                for (const participantId in newParticipants) {
                    if (participantId === userId || peerConnections[participantId] || document.getElementById(`video-container-${participantId}`)) continue;

                    const peerConnection = setupPeerConnection(participantId);
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);

                    const offersRef = collection(roomRef, 'offers');
                    await setDoc(doc(offersRef, participantId), { offer: { sdp: offer.sdp, type: offer.type }, from: userId });
                    
                    createVideoElement(participantId, newParticipants[participantId]);
                    
                    onSnapshot(doc(roomRef, 'answers', participantId), async (snapshot) => {
                         const answerData = snapshot.data();
                         if (answerData && answerData.answer && !peerConnection.currentRemoteDescription) {
                             await peerConnection.setRemoteDescription(new RTCSessionDescription(answerData.answer));
                         }
                    });
                }
                updateParticipantsList(newParticipants);
                updateWaitingRoom(data.waiting);
                updateLayout(spotlightedUser);
            });
            
            const offersRef = collection(roomRef, 'offers');
            onSnapshot(offersRef, async (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added' && change.doc.id !== userId) {
                        const offerData = change.doc.data();
                        const peerConnection = setupPeerConnection(offerData.from);
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(offerData.offer));
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        const answersRef = collection(roomRef, 'answers');
                        await setDoc(doc(answersRef, offerData.from), { answer: { sdp: answer.sdp, type: answer.type }, from: userId });
                    }
                });
            });

            const answersRef = collection(roomRef, 'answers');
            onSnapshot(answersRef, async (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added' && change.doc.id === userId) {
                        const answerData = change.doc.data();
                        const peerConnection = peerConnections[answerData.from];
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(answerData.answer));
                    }
                });
            });

            listenForUserStatus();
            listenForChat(roomRef);
            listenForWhiteboard();
            listenForDocumentShares();

            showMessage(`Room created! Share ID: ${roomName}`);
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;
            hangupBtn.disabled = false;
            sendChatBtn.disabled = false;
        };

        const joinRoom = async () => {
            const roomId = roomIdInput.value;
            if (!roomId) {
                showMessage("Please enter a Room ID.", true);
                return;
            }

            roomRef = doc(db, `artifacts/${appId}/public/data/video-rooms`, roomId);
            const roomSnapshot = await getDoc(roomRef);

            if (!roomSnapshot.exists()) {
                showMessage("Room does not exist.", true);
                return;
            }
            
            const roomData = roomSnapshot.data();
            const hostId = roomData.createdBy;

            const stream = await getLocalStream();
            if (!stream) return;
            
            await updateDoc(roomRef, { [`waiting.${userId}`]: username });
            showMessage("You are in the waiting room. Please wait for the host to admit you.");
            document.getElementById('mainApp').classList.add('hidden');

            const waitingListener = onSnapshot(roomRef, async (snapshot) => {
                const data = snapshot.data();
                if (data.participants[userId]) {
                    waitingListener();
                    document.getElementById('mainApp').classList.remove('hidden');
                    
                    createVideoElement(userId, username);
                    const localVideoElement = document.getElementById(`video-${userId}`);
                    localVideoElement.srcObject = localStream;
                    
                    const peerConnection = setupPeerConnection(hostId);
                    const offerRef = doc(roomRef, 'offers', userId);
                    const answerRef = doc(roomRef, 'answers', userId);
                    
                    await setDoc(offerRef, { offer: null, from: userId, to: hostId });

                    onSnapshot(doc(roomRef, 'answers', userId), async (snapshot) => {
                        const answerData = snapshot.data();
                        if (answerData && answerData.answer && !peerConnection.currentRemoteDescription) {
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(answerData.answer));
                        }
                    });

                    await updateDoc(roomRef, { [`status.${userId}`]: { isMuted: false, isCamOff: false, isHandRaised: false } });

                    listenForUserStatus();
                    listenForParticipants();
                    listenForChat(roomRef);
                    listenForWhiteboard();
                    listenForDocumentShares();
                    raiseHandBtn.classList.remove('hidden');
                    whiteboardTools.classList.remove('hidden');

                    showMessage(`Successfully joined room ${roomId}!`);
                    createRoomBtn.disabled = true;
                    joinRoomBtn.disabled = true;
                    hangupBtn.disabled = false;
                    sendChatBtn.disabled = false;
                } else if (data.waiting[userId] === null) {
                    waitingListener();
                    showMessage("You were denied entry by the host.", true);
                    hangup();
                }
            });
        };

        const updateParticipantsList = (participants) => {
            participantsList.style.display = 'block';
            participantsList.innerHTML = `<h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Participants</h2>`;
            for (const id in participants) {
                if (participants[id] === null) continue;
                const participantDiv = document.createElement('div');
                participantDiv.className = 'flex flex-col items-start p-2 bg-[#3c3836] rounded-sm mb-2';
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'font-semibold';
                nameSpan.textContent = `${participants[id]} ${id === userId ? '(You)' : ''}`;

                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'flex mt-2 space-x-2';

                if (isCreator && id !== userId) {
                    const kickBtn = document.createElement('button');
                    kickBtn.textContent = 'Kick';
                    kickBtn.className = 'px-3 py-1 text-sm rounded-sm bg-red-600 text-white hover:bg-red-700';
                    kickBtn.addEventListener('click', () => kickParticipant(id));
                    buttonContainer.appendChild(kickBtn);

                    const muteBtn = document.createElement('button');
                    muteBtn.textContent = 'Mute';
                    muteBtn.className = 'px-3 py-1 text-sm rounded-sm bg-yellow-600 text-white hover:bg-yellow-700';
                    muteBtn.addEventListener('click', () => muteParticipant(id));
                    buttonContainer.appendChild(muteBtn);

                    const spotlightBtn = document.createElement('button');
                    spotlightBtn.textContent = 'Spotlight';
                    spotlightBtn.className = 'px-3 py-1 text-sm rounded-sm bg-green-600 text-white hover:bg-green-700';
                    spotlightBtn.addEventListener('click', () => spotlightParticipant(id));
                    buttonContainer.appendChild(spotlightBtn);
                }
                
                participantDiv.appendChild(nameSpan);
                if (isCreator) participantDiv.appendChild(buttonContainer);
                participantsList.appendChild(participantDiv);
            }
        };

        const updateWaitingRoom = (waiting) => {
            waitingRoomList.classList.toggle('hidden', Object.keys(waiting).length === 0);
            waitingRoomList.innerHTML = `<h2 class="text-xl font-bold font-['Crimson_Pro'] mb-4">Waiting Room</h2>`;
            for (const id in waiting) {
                if (waiting[id] === null) continue;
                const waitingDiv = document.createElement('div');
                waitingDiv.className = 'flex items-center justify-between p-2 bg-[#3c3836] rounded-sm mb-2';
                waitingDiv.innerHTML = `
                    <span>${waiting[id]} is waiting...</span>
                    <div>
                        <button class="admit-btn px-3 py-1 text-sm rounded-sm bg-green-600 text-white hover:bg-green-700 mr-2" data-id="${id}">Admit</button>
                        <button class="deny-btn px-3 py-1 text-sm rounded-sm bg-red-600 text-white hover:bg-red-700" data-id="${id}">Deny</button>
                    </div>
                `;
                waitingRoomList.appendChild(waitingDiv);
            }
            document.querySelectorAll('.admit-btn').forEach(btn => btn.addEventListener('click', (e) => admitParticipant(e.target.dataset.id)));
            document.querySelectorAll('.deny-btn').forEach(btn => btn.addEventListener('click', (e) => denyParticipant(e.target.dataset.id)));
        };

        const admitParticipant = async (id) => {
            const roomDoc = await getDoc(roomRef);
            const data = roomDoc.data();
            const waitingUser = data.waiting[id];
            delete data.waiting[id];
            data.participants[id] = waitingUser;
            await updateDoc(roomRef, data);
        };

        const denyParticipant = async (id) => {
            const roomDoc = await getDoc(roomRef);
            const data = roomDoc.data();
            delete data.waiting[id];
            await updateDoc(roomRef, data);
        };

        const spotlightParticipant = async (participantId) => {
            if (isCreator && roomRef) {
                await updateDoc(roomRef, { spotlightedUser: participantId });
            }
        };

        const resetLayout = async () => {
            if (isCreator && roomRef) {
                await updateDoc(roomRef, { spotlightedUser: null });
            }
        };

        const updateLayout = (spotlightedUser) => {
            const videoContainers = document.querySelectorAll('.video-grid-item');
            if (!spotlightedUser) {
                videoContainers.forEach(container => {
                    container.style = '';
                    const video = container.querySelector('video');
                    if (video) video.style = '';
                });
                return;
            }

            videoContainers.forEach(container => {
                const id = container.id.replace('video-container-', '');
                if (id === spotlightedUser) {
                    container.style = 'grid-column: 1 / -1; grid-row: 1 / -1;';
                    const video = container.querySelector('video');
                    if (video) video.style.height = '100%';
                } else {
                    container.style = 'width: 150px; height: 100px;';
                    const video = container.querySelector('video');
                    if (video) video.style.height = '100px';
                }
            });
        };

        const kickParticipant = async (participantId) => {
            if (roomRef) {
                const roomDoc = await getDoc(roomRef);
                const participants = roomDoc.data().participants;
                delete participants[participantId];
                await updateDoc(roomRef, { participants });
                showMessage(`${participants[participantId]} has been kicked.`);
            }
        };

        const muteParticipant = async (participantId) => {
            if (roomRef) {
                const statusRef = doc(db, `artifacts/${appId}/public/data/video-rooms/${roomRef.id}/status`, participantId);
                await updateDoc(statusRef, { isMuted: true }, { merge: true });
                showMessage(`${participants[participantId]} has been muted.`);
            }
        };
        
        const muteAll = async () => {
            if (isCreator && roomRef) {
                const participantsDoc = await getDoc(roomRef);
                const participants = participantsDoc.data().participants || {};
                const promises = Object.keys(participants).map(id => {
                    const statusRef = doc(db, `artifacts/${appId}/public/data/video-rooms/${roomRef.id}/status`, id);
                    return updateDoc(statusRef, { isMuted: true }, { merge: true });
                });
                await Promise.all(promises);
                showMessage("All participants have been muted.");
            }
        };

        const hangup = async () => {
            for (const peerId in peerConnections) {
                peerConnections[peerId].close();
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            if (screenShareStream) {
                screenShareStream.getTracks().forEach(track => track.stop());
            }
            videoFeeds.innerHTML = '';
            
            if (roomSnapshotListener) roomSnapshotListener();
            if (roomsListener) roomsListener();
            if (participantsListener) participantsListener();
            if (userStatusListener) userStatusListener();
            if (whiteboardListener) whiteboardListener();
            if (documentShareListener) documentShareListener();

            if (roomRef) {
                const userPath = `participants.${userId}`;
                await updateDoc(roomRef, { [userPath]: null });
                const roomDoc = await getDoc(roomRef);
                const participants = roomDoc.data().participants;
                const remainingParticipants = Object.keys(participants).filter(key => participants[key] !== null);
                
                if (remainingParticipants.length === 0) {
                    try {
                        await deleteDoc(roomRef);
                    } catch (error) {
                        console.error("Error deleting empty room data:", error);
                    }
                }
            }
            isCreator = false;
            participantsList.style.display = 'none';
            waitingRoomList.classList.add('hidden');
            whiteboardHostControls.classList.add('hidden');
            raiseHandBtn.classList.add('hidden');
            resetLayoutBtn.classList.add('hidden');

            roomIdInput.value = '';
            hideMessage();
            createRoomBtn.disabled = false;
            joinRoomBtn.disabled = false;
            hangupBtn.disabled = true;
            sendChatBtn.disabled = true;
            toggleAudioBtn.disabled = true;
            toggleVideoBtn.disabled = true;
            screenShareBtn.disabled = true;
            startRecordingBtn.disabled = true;
            chatContainer.innerHTML = '';
            whiteboardCanvas.classList.add('hidden');
            whiteboardTools.classList.add('hidden');
        };

        const toggleAudio = async () => {
            if (localStream && localStream.getAudioTracks().length > 0) {
                const audioTrack = localStream.getAudioTracks()[0];
                audioTrack.enabled = !audioTrack.enabled;
                updateButtonState();
                if (roomRef) {
                    const statusRef = doc(db, `artifacts/${appId}/public/data/video-rooms/${roomRef.id}/status`, userId);
                    await setDoc(statusRef, { isMuted: !audioTrack.enabled }, { merge: true });
                }
            }
        };

        const toggleVideo = async () => {
            if (localStream && localStream.getVideoTracks().length > 0) {
                const videoTrack = localStream.getVideoTracks()[0];
                videoTrack.enabled = !videoTrack.enabled;
                updateButtonState();
                if (roomRef) {
                    const statusRef = doc(db, `artifacts/${appId}/public/data/video-rooms/${roomRef.id}/status`, userId);
                    await setDoc(statusRef, { isCamOff: !videoTrack.enabled }, { merge: true });
                }
            }
        };
        
        const toggleScreenShare = async () => {
            if (screenShareStream) {
                screenShareStream.getTracks().forEach(track => track.stop());
                screenShareStream = null;
                localStream.getVideoTracks()[0].enabled = true; // Re-enable camera
                screenShareBtn.textContent = 'Share Screen';
                updateButtonState();
            } else {
                try {
                    screenShareStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                    localStream.getVideoTracks()[0].enabled = false; // Disable camera
                    screenShareStream.getTracks().forEach(track => {
                        for (const peerId in peerConnections) {
                            const sender = peerConnections[peerId].getSenders().find(s => s.track.kind === 'video');
                            sender.replaceTrack(track);
                        }
                    });
                    screenShareBtn.textContent = 'Stop Sharing';
                    updateButtonState();
                } catch (error) {
                    console.error("Screen sharing failed:", error);
                    showMessage("Screen sharing was denied or failed.", true);
                    localStream.getVideoTracks()[0].enabled = true;
                    updateButtonState();
                }
            }
        };

        const startRecording = () => {
            if (isRecording) {
                mediaRecorder.stop();
                return;
            }
            isRecording = true;
            startRecordingBtn.textContent = 'Stop Recording';
            startRecordingBtn.classList.remove('btn-primary');
            startRecordingBtn.classList.add('btn-danger');
            recordingIndicator.classList.remove('hidden');

            recordingCanvas.width = videoFeeds.offsetWidth;
            recordingCanvas.height = videoFeeds.offsetHeight;

            const canvasStream = recordingCanvas.captureStream(25);
            const audioTracks = [];
            if (localStream && localStream.getAudioTracks().length > 0) {
                audioTracks.push(localStream.getAudioTracks()[0]);
            }
            for (const id in peerConnections) {
                const remoteStream = peerConnections[id].getRemoteStreams()[0];
                if (remoteStream && remoteStream.getAudioTracks().length > 0) {
                    audioTracks.push(remoteStream.getAudioTracks()[0]);
                }
            }
            if (audioTracks.length > 0) {
                const combinedAudio = audioCtx.createMediaStreamDestination();
                audioTracks.forEach(track => {
                    const source = audioCtx.createMediaStreamSource(new MediaStream([track]));
                    source.connect(combinedAudio);
                });
                combinedAudio.stream.getAudioTracks().forEach(track => canvasStream.addTrack(track));
            }
            
            mediaRecorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm' });
            recordedChunks = [];

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                downloadRecording.href = url;
                downloadRecording.download = `conference-recording-${Date.now()}.webm`;
                downloadRecording.click();
                URL.revokeObjectURL(url);
                showMessage("Recording saved to your downloads.");
                
                isRecording = false;
                startRecordingBtn.textContent = 'Start Recording';
                startRecordingBtn.classList.remove('btn-danger');
                startRecordingBtn.classList.add('btn-primary');
                recordingIndicator.classList.add('hidden');
                clearInterval(drawingInterval);
            };

            const drawVideos = () => {
                const videos = document.querySelectorAll('#videoFeeds video');
                if (videos.length === 0) return;
                
                canvasCtx.fillStyle = '#1d2021';
                canvasCtx.fillRect(0, 0, recordingCanvas.width, recordingCanvas.height);
                
                let x = 0;
                let y = 0;
                let maxHeight = 0;

                videos.forEach(video => {
                    if (x + video.offsetWidth > recordingCanvas.width) {
                        x = 0;
                        y += maxHeight + 10;
                        maxHeight = 0;
                    }

                    canvasCtx.drawImage(video, x, y, video.offsetWidth, video.offsetHeight);
                    x += video.offsetWidth + 10;
                    if (video.offsetHeight > maxHeight) {
                        maxHeight = video.offsetHeight;
                    }
                });
            };
            drawingInterval = setInterval(drawVideos, 100);
            mediaRecorder.start();
            showMessage("Recording started.");
        };

        const sendMessage = async () => {
            const message = chatInput.value.trim();
            if (message === "" || !roomRef) return;

            const chatMessagesRef = collection(roomRef, 'chat-messages');
            await addDoc(chatMessagesRef, {
                senderId: userId,
                senderUsername: username,
                text: message,
                timestamp: serverTimestamp()
            });
            chatInput.value = '';
        };

        const listenForChat = (roomDocRef) => {
            const chatMessagesRef = collection(roomDocRef, 'chat-messages');
            onSnapshot(chatMessagesRef, (snapshot) => {
                snapshot.docChanges().forEach(change => {
                    if (change.type === 'added') {
                        const messageData = change.doc.data();
                        displayMessage(messageData);
                    }
                });
            }, (error) => {
                console.error("Error listening to chat messages:", error);
            });
        };

        const listenForUserStatus = () => {
            if (userStatusListener) userStatusListener();
            const statusCollectionRef = collection(db, `artifacts/${appId}/public/data/video-rooms/${roomRef.id}/status`);
            userStatusListener = onSnapshot(statusCollectionRef, (snapshot) => {
                snapshot.docChanges().forEach(change => {
                    if (change.type === 'modified' || change.type === 'added') {
                        const statusData = change.doc.data();
                        const participantId = change.doc.id;
                        const audioIcon = document.getElementById(`audio-icon-${participantId}`);
                        const videoIcon = document.getElementById(`video-icon-${participantId}`);
                        const handIcon = document.getElementById(`hand-icon-${participantId}`);

                        if (audioIcon) {
                            audioIcon.className = `fas ${statusData.isMuted ? 'fa-microphone-slash text-red-400' : 'fa-microphone text-green-400'}`;
                        }
                        if (videoIcon) {
                            videoIcon.className = `fas ${statusData.isCamOff ? 'fa-video-slash text-red-400' : 'fa-video text-green-400'}`;
                        }
                        if (handIcon) {
                            handIcon.classList.toggle('hidden', !statusData.isHandRaised);
                        }
                        
                        if (participantId === userId) {
                            if (statusData.isMuted) {
                                if (localStream.getAudioTracks().length > 0) localStream.getAudioTracks()[0].enabled = false;
                            }
                        }
                    }
                });
            });
        };

        const toggleHandRaise = async () => {
            isHandRaised = !isHandRaised;
            raiseHandBtn.classList.toggle('btn-toggle-active', isHandRaised);
            if (roomRef) {
                const statusRef = doc(db, `artifacts/${appId}/public/data/video-rooms/${roomRef.id}/status`, userId);
                await setDoc(statusRef, { isHandRaised: isHandRaised }, { merge: true });
            }
        };

        const listenForWhiteboard = () => {
            if (whiteboardListener) whiteboardListener();
            const whiteboardRef = doc(roomRef, 'whiteboard', 'data');
            whiteboardListener = onSnapshot(whiteboardRef, (snapshot) => {
                const data = snapshot.data();
                if (data && data.isActive) {
                    whiteboardCanvas.classList.remove('hidden');
                    drawWhiteboard(data.data);
                } else {
                    whiteboardCanvas.classList.add('hidden');
                    whiteboardCtx.clearRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
                }
            });
        };

        const initWhiteboard = () => {
            whiteboardCanvas.width = videoFeeds.offsetWidth;
            whiteboardCanvas.height = videoFeeds.offsetHeight;
            whiteboardCtx = whiteboardCanvas.getContext('2d');
            whiteboardCtx.strokeStyle = currentWhiteboardColor;
            whiteboardCtx.lineWidth = currentWhiteboardSize;
            whiteboardCtx.lineCap = 'round';
            whiteboardCtx.lineJoin = 'round';
            
            whiteboardCanvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                [lastX, lastY] = [e.offsetX, e.offsetY];
                drawAndSend([lastX, lastY], false, currentWhiteboardColor, currentWhiteboardSize);
            });
            whiteboardCanvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                drawAndSend([e.offsetX, e.offsetY], true, currentWhiteboardColor, currentWhiteboardSize);
                [lastX, lastY] = [e.offsetX, e.offsetY];
            });
            whiteboardCanvas.addEventListener('mouseup', () => isDrawing = false);
            whiteboardCanvas.addEventListener('mouseout', () => isDrawing = false);
            whiteboardTools.classList.remove('hidden');
        };

        const drawAndSend = async (coords, isDrawing, color, size) => {
            if (roomRef) {
                const whiteboardRef = doc(roomRef, 'whiteboard', 'data');
                const docSnap = await getDoc(whiteboardRef);
                const whiteboardData = docSnap.data().data || [];
                await updateDoc(whiteboardRef, {
                    data: [...whiteboardData, { coords, isDrawing, color, size }]
                });
            }
        };

        const drawWhiteboard = (data) => {
            whiteboardCtx.clearRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
            whiteboardCtx.beginPath();
            data.forEach((point, i) => {
                whiteboardCtx.strokeStyle = point.color;
                whiteboardCtx.lineWidth = point.size;
                if (point.isDrawing && data[i-1]) {
                    whiteboardCtx.moveTo(data[i-1].coords[0], data[i-1].coords[1]);
                    whiteboardCtx.lineTo(point.coords[0], point.coords[1]);
                    whiteboardCtx.stroke();
                } else {
                    whiteboardCtx.moveTo(point.coords[0], point.coords[1]);
                }
            });
        };

        const toggleWhiteboard = async () => {
            isWhiteboardActive = !isWhiteboardActive;
            const whiteboardRef = doc(roomRef, 'whiteboard', 'data');
            await setDoc(whiteboardRef, { isActive: isWhiteboardActive, data: [] });
            toggleWhiteboardBtn.textContent = isWhiteboardActive ? "Stop Whiteboard" : "Start Whiteboard";
        };
        
        const clearWhiteboard = async () => {
            if (isCreator && roomRef) {
                const whiteboardRef = doc(roomRef, 'whiteboard', 'data');
                await updateDoc(whiteboardRef, { data: [] });
            }
        };
        
        const uploadAndShareFile = async (file) => {
            if (!file) return;
            showMessage(`Uploading ${file.name}...`);
            const fileRef = ref(storage, `artifacts/${appId}/public/shared-files/${roomRef.id}/${file.name}`);
            try {
                await uploadBytes(fileRef, file);
                const downloadUrl = await getDownloadURL(fileRef);
                await setDoc(doc(roomRef, 'sharedFiles', Date.now().toString()), { 
                    url: downloadUrl,
                    name: file.name,
                    sender: username,
                    timestamp: serverTimestamp()
                });
                showMessage("File shared successfully!", false);
            } catch (error) {
                console.error("File upload failed:", error);
                showMessage("File upload failed.", true);
            }
        };

        const listenForDocumentShares = () => {
            if (documentShareListener) documentShareListener();
            const sharedFilesRef = collection(roomRef, 'sharedFiles');
            documentShareListener = onSnapshot(sharedFilesRef, (snapshot) => {
                snapshot.docChanges().forEach(change => {
                    if (change.type === 'added') {
                        const fileData = change.doc.data();
                        showDocumentViewer(fileData);
                    }
                });
            });
        };

        const showDocumentViewer = (fileData) => {
            documentViewerContent.innerHTML = '';
            
            const fileLink = document.createElement('a');
            fileLink.href = fileData.url;
            fileLink.target = '_blank';
            fileLink.textContent = `Shared by ${fileData.sender}: ${fileData.name}`;
            fileLink.className = 'text-blue-400 hover:text-blue-300 underline';
            documentViewerContent.appendChild(fileLink);

            documentViewer.classList.remove('hidden');
        };

        const displayMessage = (messageData) => {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${messageData.senderId === userId ? 'my-message' : 'other-message'}`;
            messageDiv.innerHTML = `<span class="font-bold">${messageData.senderUsername}:</span> ${messageData.text}`;
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        };

        const setUsername = async () => {
            const user = usernameInput.value.trim();
            if (user) {
                username = user;
                usernamePrompt.style.display = 'none';
                deviceSelection.style.display = 'flex';
                await getDevices();
                
                await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                await getDevices();
            } else {
                showMessage("Please enter a username.", true);
            }
        };

        const deleteAllRooms = async () => {
            confirmationModal.classList.remove('hidden');
        };
        
        const confirmDelete = async () => {
            confirmationModal.classList.add('hidden');
            if (isCreator) {
                showMessage("Deleting all rooms...");
                const roomCollectionRef = collection(db, `artifacts/${appId}/public/data/video-rooms`);
                const roomDocs = await getDocs(roomCollectionRef);
                const deletePromises = roomDocs.docs.map(roomDoc => deleteDoc(roomDoc.ref));
                await Promise.all(deletePromises);
                showMessage("All rooms have been deleted.");
            } else {
                showMessage("Only the host can delete all rooms.", true);
            }
        };

        const cancelDelete = () => {
            confirmationModal.classList.add('hidden');
        };
        
        // Event Listeners
        window.onload = () => {
            initFirebase();
        };

        submitUsernameBtn.addEventListener('click', setUsername);
        usernameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') setUsername();
        });

        startCallBtn.addEventListener('click', async () => {
            localStream = await getLocalStream();
            if (!localStream) {
                showMessage("Failed to get media stream. Please check permissions and try again.", true);
                return;
            }
            deviceSelection.style.display = 'none';
            mainApp.style.display = 'grid';
            updateButtonState();
        });

        createRoomBtn.addEventListener('click', createRoom);
        joinRoomBtn.addEventListener('click', joinRoom);
        hangupBtn.addEventListener('click', hangup);
        toggleAudioBtn.addEventListener('click', toggleAudio);
        toggleVideoBtn.addEventListener('click', toggleVideo);
        screenShareBtn.addEventListener('click', toggleScreenShare);
        startRecordingBtn.addEventListener('click', startRecording);
        sendChatBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') sendMessage();
        });
        toggleWhiteboardBtn.addEventListener('click', toggleWhiteboard);
        whiteboardClearBtn.addEventListener('click', clearWhiteboard);
        whiteboardColorPicker.addEventListener('change', (e) => {
            currentWhiteboardColor = e.target.value;
            whiteboardCtx.strokeStyle = currentWhiteboardColor;
        });
        whiteboardLineSize.addEventListener('change', (e) => {
            currentWhiteboardSize = parseInt(e.target.value);
            whiteboardCtx.lineWidth = currentWhiteboardSize;
        });
        raiseHandBtn.addEventListener('click', toggleHandRaise);
        uploadFileBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                fileNameDisplay.textContent = `Selected: ${file.name}`;
                uploadAndShareFile(file);
            }
        });
        closeDocumentViewerBtn.addEventListener('click', () => {
            documentViewer.classList.add('hidden');
        });
        deleteAllRoomsBtn.addEventListener('click', deleteAllRooms);
        confirmDeleteBtn.addEventListener('click', confirmDelete);
        cancelDeleteBtn.addEventListener('click', cancelDelete);
    </script>
</body>
</html>
