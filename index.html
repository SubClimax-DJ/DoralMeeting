<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gruvbox Video Conference</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'gruv-bg': '#282828',
                        'gruv-red': '#cc241d',
                        'gruv-green': '#98971a',
                        'gruv-yellow': '#d79921',
                        'gruv-blue': '#458588',
                        'gruv-purple': '#b16286',
                        'gruv-aqua': '#689d6a',
                        'gruv-gray': '#a89984',
                        'gruv-light-gray': '#928374',
                        'gruv-fg': '#ebdbb2',
                        'crimson': '#dc143c',
                        'navy': '#000080',
                        'silver': '#c0c0c0',
                    }
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .video-pip {
            width: 25%;
            max-width: 200px;
            border: 2px solid #a89984;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body class="bg-gruv-bg text-gruv-fg h-full flex items-center justify-center antialiased">

    <div id="app-container" class="w-full h-full max-w-6xl mx-auto flex flex-col p-4">

        <!-- Login Page -->
        <div id="login-page" class="flex flex-col items-center justify-center h-full">
            <div class="w-full max-w-sm bg-gruv-light-gray/10 p-8 rounded-lg shadow-lg border border-gruv-gray/20">
                <h1 class="text-3xl font-bold mb-6 text-center text-gruv-aqua">Join Conference</h1>
                <input type="text" id="username" placeholder="Enter your username" class="w-full p-3 mb-4 bg-gruv-bg border border-gruv-gray/30 rounded-md focus:outline-none focus:ring-2 focus:ring-gruv-aqua">
                <input type="password" id="password" placeholder="Enter password for admin" class="w-full p-3 mb-4 bg-gruv-bg border border-gruv-gray/30 rounded-md focus:outline-none focus:ring-2 focus:ring-gruv-aqua hidden">
                <button id="join-btn" class="w-full bg-gruv-blue hover:bg-gruv-aqua text-white font-bold py-3 px-4 rounded-md transition duration-300">Join Lobby</button>
                 <p id="login-error" class="text-gruv-red mt-4 text-center"></p>
            </div>
        </div>

        <!-- Waiting Lobby -->
        <div id="lobby-page" class="hidden flex-1 flex gap-4">
            <div class="w-1/3 bg-gruv-light-gray/10 rounded-lg shadow-lg p-4 flex flex-col border border-gruv-gray/20">
                <div class="flex justify-between items-center border-b border-gruv-gray/20 pb-2 mb-4">
                    <h2 class="text-xl font-bold text-gruv-aqua">Active Users</h2>
                    <button id="logout-btn" class="bg-gruv-red hover:bg-red-700 text-white text-sm font-bold py-1 px-3 rounded-md transition">Logout</button>
                </div>
                <div id="user-list" class="flex-1 overflow-y-auto"></div>
            </div>
            <div class="w-2/3 bg-gruv-light-gray/10 rounded-lg shadow-lg p-4 flex flex-col border border-gruv-gray/20">
                <h2 class="text-xl font-bold mb-4 text-gruv-aqua border-b border-gruv-gray/20 pb-2">Lobby Chat</h2>
                <div id="chat-box" class="flex-1 overflow-y-auto mb-4 p-2 bg-gruv-bg/50 rounded-md"></div>
                <form id="chat-form" class="flex gap-2">
                    <input type="text" id="chat-input" placeholder="Type a message..." class="flex-1 p-3 bg-gruv-bg border border-gruv-gray/30 rounded-md focus:outline-none focus:ring-2 focus:ring-gruv-aqua">
                    <button type="submit" class="bg-gruv-blue hover:bg-gruv-aqua text-white font-bold py-3 px-4 rounded-md transition duration-300">Send</button>
                </form>
            </div>
        </div>

        <!-- Video Conference Room -->
        <div id="call-page" class="hidden flex-1 flex-col items-center justify-center bg-black/50 rounded-lg">
             <div class="relative w-full h-full flex items-center justify-center p-4">
                <video id="remoteVideo" autoplay playsinline class="w-full h-full object-contain rounded-lg"></video>
                <video id="localVideo" autoplay playsinline muted class="absolute bottom-4 right-4 video-pip"></video>
            </div>
            <div class="flex items-center gap-4 p-4 bg-gruv-light-gray/10 rounded-b-lg w-full justify-center">
                <button id="mic-btn" class="bg-gruv-blue p-3 rounded-full text-white hover:bg-gruv-aqua transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" /></svg>
                </button>
                <button id="camera-btn" class="bg-gruv-blue p-3 rounded-full text-white hover:bg-gruv-aqua transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.55a1 1 0 011.45.89V18.1a1 1 0 01-1.45.89L15 15M4 9a2 2 0 012-2h4a2 2 0 012 2v6a2 2 0 01-2 2H6a2 2 0 01-2-2V9z" /></svg>
                </button>
                <button id="screen-share-btn" class="bg-gruv-blue p-3 rounded-full text-white hover:bg-gruv-aqua transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                    </svg>
                </button>
                <button id="hangup-btn" class="bg-gruv-red p-3 rounded-full text-white hover:bg-red-700 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 8l2-2m0 0l2 2m-2-2v12a2 2 0 01-2 2H8a2 2 0 01-2-2V6m0 0l2 2m-2-2l2-2" transform="rotate(135 12 12)" /></svg>
                </button>
            </div>
        </div>

        <!-- Call Notification Modal -->
        <div id="call-notification" class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-50">
            <div class="bg-gruv-light-gray/20 p-8 rounded-lg shadow-2xl border border-gruv-gray/30 text-center w-full max-w-sm backdrop-blur-sm">
                <h2 class="text-2xl font-bold mb-4 text-gruv-aqua">Incoming Call</h2>
                <p id="caller-info" class="mb-6 text-lg"></p>
                <div class="flex justify-center gap-4">
                    <button id="accept-call-btn" class="bg-gruv-green hover:bg-gruv-aqua text-white font-bold py-3 px-6 rounded-md transition duration-300">Accept</button>
                    <button id="decline-call-btn" class="bg-gruv-red hover:bg-red-700 text-white font-bold py-3 px-6 rounded-md transition duration-300">Decline</button>
                </div>
            </div>
        </div>

        <!-- Toast Notification -->
        <div id="toast-notification" class="hidden fixed top-5 right-5 bg-gruv-red text-white py-3 px-5 rounded-lg shadow-lg z-50">
            <p id="toast-message"></p>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getAuth, signOut, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFirestore, collection, doc, addDoc, onSnapshot, updateDoc, deleteDoc, getDoc } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        import { getDatabase, ref, onValue, set, push, onChildAdded, onDisconnect, serverTimestamp, remove } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBluS1Dl9abDJjPPeOhvTCfP8J1kyIh6BQ",
            authDomain: "video-meeting-e73eb.firebaseapp.com",
            projectId: "video-meeting-e73eb",
            storageBucket: "video-meeting-e73eb.firebasestorage.app",
            messagingSenderId: "80496795033",
            appId: "1:80496795033:web:3ac35c631d76301f77c708",
            measurementId: "G-SFPQ0PJRPG"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const rtdb = getDatabase(app);

        // DOM Elements
        const loginPage = document.getElementById('login-page');
        const lobbyPage = document.getElementById('lobby-page');
        const callPage = document.getElementById('call-page');
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');
        const joinBtn = document.getElementById('join-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const loginError = document.getElementById('login-error');
        const userList = document.getElementById('user-list');
        const chatBox = document.getElementById('chat-box');
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const micBtn = document.getElementById('mic-btn');
        const cameraBtn = document.getElementById('camera-btn');
        const screenShareBtn = document.getElementById('screen-share-btn');
        const hangupBtn = document.getElementById('hangup-btn');
        const callNotification = document.getElementById('call-notification');
        const callerInfo = document.getElementById('caller-info');
        const acceptCallBtn = document.getElementById('accept-call-btn');
        const declineCallBtn = document.getElementById('decline-call-btn');
        const toastNotification = document.getElementById('toast-notification');
        const toastMessage = document.getElementById('toast-message');


        // App State
        let localStream;
        let webcamStream; // To store the webcam stream separately
        let screenStream; // To store the screen share stream
        let pc;
        let user = null;
        let isAdmin = false;
        let currentCallId = null;
        let callListener = null;
        let incomingCallData = null;
        let isScreenSharing = false;

        const servers = {
            iceServers: [
                { urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'] },
            ],
            iceCandidatePoolSize: 10,
        };

        // --- Login and Auth ---
        usernameInput.addEventListener('input', () => {
            if (usernameInput.value.toLowerCase() === 'admin') {
                passwordInput.classList.remove('hidden');
            } else {
                passwordInput.classList.add('hidden');
            }
        });

        joinBtn.onclick = async () => {
            const username = usernameInput.value.trim();
            loginError.textContent = '';
            
            if (!username) {
                loginError.textContent = 'Please enter a username.';
                return;
            }

            if (username.toLowerCase() === 'admin') {
                if (passwordInput.value !== 'max') {
                    loginError.textContent = 'Incorrect password for admin.';
                    return;
                }
                isAdmin = true;
            }
            
            try {
                await signInAnonymously(auth);
            } catch (error) {
                console.error("Anonymous sign-in failed:", error);
                loginError.textContent = 'Failed to connect. Please try again.';
            }
        };
        
        onAuthStateChanged(auth, async (currentUser) => {
            if (currentUser) {
                user = {
                    uid: currentUser.uid,
                    username: usernameInput.value.trim()
                };
                setupPresence();
                showLobby();
                listenForCalls();
            } else {
                user = null;
                showLogin();
            }
        });

        logoutBtn.onclick = async () => {
            if (user) {
                const myStatusRef = ref(rtdb, `status/${user.uid}`);
                await remove(myStatusRef);
            }
            await signOut(auth);
            usernameInput.value = '';
            passwordInput.value = '';
            passwordInput.classList.add('hidden');
            isAdmin = false;
        };

        // --- UI Navigation ---
        function showLogin() {
            loginPage.classList.remove('hidden');
            lobbyPage.classList.add('hidden');
            callPage.classList.add('hidden');
            loginPage.classList.add('flex');
            lobbyPage.classList.remove('flex');
            callPage.classList.remove('flex', 'flex-col');
        }

        function showLobby() {
            loginPage.classList.add('hidden');
            lobbyPage.classList.remove('hidden');
            callPage.classList.add('hidden');
            loginPage.classList.remove('flex');
            lobbyPage.classList.add('flex');
            callPage.classList.remove('flex', 'flex-col');
        }

        function showCall() {
            loginPage.classList.add('hidden');
            lobbyPage.classList.add('hidden');
            callPage.classList.remove('hidden');
            loginPage.classList.remove('flex');
            lobbyPage.classList.remove('flex');
            callPage.classList.add('flex', 'flex-col');
        }
        
        // --- Presence and Lobby ---
        async function setupPresence() {
            const myStatusRef = ref(rtdb, `status/${user.uid}`);
            const presenceData = {
                username: user.username,
                online: true,
                isAdmin: isAdmin,
                timestamp: serverTimestamp()
            };
            
            onDisconnect(myStatusRef).remove();
            await set(myStatusRef, presenceData);

            const statusRef = ref(rtdb, 'status');
            onValue(statusRef, (snapshot) => {
                const statuses = snapshot.val();
                renderUserList(statuses);
            });
        }
        
        function renderUserList(users) {
            userList.innerHTML = '';
            if(!users) return;

            for (const uid in users) {
                if (user && uid === user.uid) continue; // Don't show self
                
                const userData = users[uid];
                const userDiv = document.createElement('div');
                userDiv.className = 'flex items-center justify-between p-2 my-1 rounded-md bg-gruv-bg/50';
                userDiv.innerHTML = `<span class="font-semibold">${userData.username}</span>`;
                
                if (isAdmin) {
                    const callButton = document.createElement('button');
                    callButton.textContent = 'Call';
                    callButton.className = 'bg-gruv-green hover:bg-gruv-aqua text-white text-sm font-bold py-1 px-3 rounded-md transition';
                    callButton.onclick = () => startCall(uid, userData.username);
                    userDiv.appendChild(callButton);
                }
                userList.appendChild(userDiv);
            }
        }
        
        // --- Lobby Chat ---
        const chatRef = ref(rtdb, 'chat');
        chatForm.onsubmit = (e) => {
            e.preventDefault();
            const messageText = chatInput.value.trim();
            if (messageText) {
                push(chatRef, {
                    username: user.username,
                    text: messageText,
                    timestamp: serverTimestamp()
                });
                chatInput.value = '';
            }
        };

        onChildAdded(chatRef, (snapshot) => {
            const msg = snapshot.val();
            const msgDiv = document.createElement('div');
            msgDiv.innerHTML = `<span class="font-bold text-gruv-aqua">${msg.username}:</span> ${msg.text}`;
            chatBox.appendChild(msgDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
        });

        // --- WebRTC Call Logic ---

        async function startCall(calleeId, calleeUsername) {
            console.log(`Starting call to ${calleeUsername} (${calleeId})`);
            currentCallId = (await addDoc(collection(db, 'calls'), { 
                callerId: user.uid,
                callerUsername: user.username,
                calleeId: calleeId,
                calleeUsername: calleeUsername,
            })).id;
            
            console.log(`Call document created with ID: ${currentCallId}`);
            
            showCall();
            setupPeerConnection();

            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            webcamStream = localStream; // Save webcam stream
            localVideo.srcObject = localStream;
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

            const offerDescription = await pc.createOffer();
            await pc.setLocalDescription(offerDescription);

            const callDoc = doc(db, 'calls', currentCallId);
            await updateDoc(callDoc, { offer: { sdp: offerDescription.sdp, type: offerDescription.type } });
            console.log("Offer sent.");

            listenForAnswer(callDoc);
            listenForIceCandidates(callDoc, 'calleeCandidates', 'callerCandidates');
        }
        
        async function listenForCalls() {
            console.log("Listening for incoming calls...");
            onSnapshot(collection(db, 'calls'), (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    const callData = change.doc.data();
                    const callId = change.doc.id;
                    
                    // A more robust check: Instead of only looking for `added` docs,
                    // we check any document that is for us, has an offer, and that we're not already in a call.
                    if (callData.calleeId === user.uid && callData.offer && !currentCallId) {
                        console.log(`Incoming call detected from ${callData.callerUsername} with ID: ${callId}`);
                        incomingCallData = {
                            id: callId,
                            offer: callData.offer,
                            callerUsername: callData.callerUsername
                        };
                        callerInfo.textContent = `${callData.callerUsername} is calling you.`;
                        callNotification.classList.remove('hidden');
                    }
                });
            });
        }
        
        async function answerCall(offer) {
            console.log(`Answering call ID: ${currentCallId}`);
            showCall();
            setupPeerConnection();
            
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            webcamStream = localStream; // Save webcam stream
            localVideo.srcObject = localStream;
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

            await pc.setRemoteDescription(new RTCSessionDescription(offer));
            
            const answerDescription = await pc.createAnswer();
            await pc.setLocalDescription(answerDescription);

            const callDoc = doc(db, 'calls', currentCallId);
            await updateDoc(callDoc, { answer: { sdp: answerDescription.sdp, type: answerDescription.type } });
            console.log("Answer sent.");
            
            listenForIceCandidates(callDoc, 'callerCandidates', 'calleeCandidates');
        }

        function listenForAnswer(callDoc) {
             onSnapshot(callDoc, (snapshot) => {
                if (!snapshot.exists()) {
                    showToast('The call was ended or declined.');
                    hangUp(); // hangUp already cleans everything up
                    return;
                }
                const data = snapshot.data();
                if (!pc.currentRemoteDescription && data?.answer) {
                    const answerDescription = new RTCSessionDescription(data.answer);
                    pc.setRemoteDescription(answerDescription);
                }
            });
        }
        
        function listenForIceCandidates(callDoc, listenToCollection, writeToCollection) {
            const candidateCollection = collection(db, callDoc.path, listenToCollection);
            onSnapshot(candidateCollection, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added') {
                        const candidate = new RTCIceCandidate(change.doc.data());
                        pc.addIceCandidate(candidate);
                    }
                });
            });
            
             pc.onicecandidate = event => {
                if (event.candidate) {
                    addDoc(collection(db, callDoc.path, writeToCollection), event.candidate.toJSON());
                }
            };
        }

        function setupPeerConnection() {
            pc = new RTCPeerConnection(servers);
            
            pc.ontrack = event => {
                remoteVideo.srcObject = event.streams[0];
            };
        }
        
        async function hangUp() {
            if (isScreenSharing) {
                await stopScreenShare();
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            if (webcamStream) {
                 webcamStream.getTracks().forEach(track => track.stop());
            }
            if (pc) {
                pc.close();
            }
            
            remoteVideo.srcObject = null;
            localVideo.srcObject = null;
            
            if (currentCallId) {
                const callDoc = doc(db, 'calls', currentCallId);
                if ((await getDoc(callDoc)).exists()){
                     await deleteDoc(callDoc);
                }
            }
            
            currentCallId = null;
            pc = null;
            showLobby();
        }

        hangupBtn.onclick = hangUp;
        
        acceptCallBtn.onclick = async () => {
            if (incomingCallData) {
                currentCallId = incomingCallData.id;
                await answerCall(incomingCallData.offer);
                incomingCallData = null;
                callNotification.classList.add('hidden');
            }
        };

        declineCallBtn.onclick = async () => {
            if (incomingCallData) {
                const callDoc = doc(db, 'calls', incomingCallData.id);
                await deleteDoc(callDoc);
                incomingCallData = null;
                callNotification.classList.add('hidden');
            }
        };

        function showToast(message) {
            toastMessage.textContent = message;
            toastNotification.classList.remove('hidden');
            setTimeout(() => {
                toastNotification.classList.add('hidden');
            }, 3000);
        }

        // --- Call Controls ---
        micBtn.onclick = () => {
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !track.enabled;
                micBtn.classList.toggle('bg-gruv-red', !track.enabled);
                micBtn.classList.toggle('bg-gruv-blue', track.enabled);
            });
        };
        
        cameraBtn.onclick = () => {
            localStream.getVideoTracks().forEach(track => {
                track.enabled = !track.enabled;
                cameraBtn.classList.toggle('bg-gruv-red', !track.enabled);
                cameraBtn.classList.toggle('bg-gruv-blue', track.enabled);
            });
        };

        const stopScreenShare = async () => {
            if (!isScreenSharing) return;
            
            const videoTrack = webcamStream.getVideoTracks()[0];
            const sender = pc.getSenders().find(s => s.track.kind === 'video');
            if (sender) {
                await sender.replaceTrack(videoTrack);
            }

            screenStream.getTracks().forEach(track => track.stop());
            localStream = webcamStream;
            localVideo.srcObject = localStream;
            isScreenSharing = false;
            screenShareBtn.classList.remove('bg-gruv-green');
            screenShareBtn.classList.add('bg-gruv-blue');
        };
        
        screenShareBtn.onclick = async () => {
            if (isScreenSharing) {
                await stopScreenShare();
                return;
            }

            isScreenSharing = true;
            screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
            
            const screenTrack = screenStream.getVideoTracks()[0];
            const sender = pc.getSenders().find(s => s.track.kind === 'video');
            if (sender) {
                await sender.replaceTrack(screenTrack);
            }
            
            localVideo.srcObject = screenStream; // Show screen share in PiP
            
            screenShareBtn.classList.remove('bg-gruv-blue');
            screenShareBtn.classList.add('bg-gruv-green');

            // Listen for when the user stops screen sharing via browser UI
            screenTrack.onended = () => {
                stopScreenShare();
            };
        };
        
    </script>
</body>
</html>


