<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parent-Teacher Video Conference</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-dark: #282828;
            --bg-medium: #3c3836;
            --fg-light: #ebdbb2;
            --fg-dark: #a89984;
            --red: #cc241d;
            --green: #98971a;
            --yellow: #d79921;
            --blue: #458588;
            --purple: #b16286;
            --aqua: #689d6a;
            --orange: #d65d0e;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--fg-light);
        }

        .gruvbox-card {
            background-color: var(--bg-medium);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--fg-dark);
        }

        .btn {
            background-color: var(--blue);
            color: var(--fg-light);
            transition: background-color 0.3s ease;
        }

        .btn-green {
            background-color: var(--green);
        }

        .btn-red {
            background-color: var(--red);
        }

        .btn:hover {
            background-color: var(--aqua);
        }
        .btn-green:hover {
            background-color: var(--aqua);
        }
        .btn-red:hover {
            background-color: var(--orange);
        }

        .chat-container {
            border: 1px solid var(--fg-dark);
            height: 300px;
        }

        .user-list {
            max-height: 400px;
        }

        video {
            border: 2px solid var(--purple);
            border-radius: 8px;
            background-color: #000;
        }

        .hidden {
            display: none;
        }

        /* Responsive video containers */
        #call-screen-videos {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        @media (min-width: 768px) {
            #call-screen-videos {
                flex-direction: row;
            }
        }
    </style>
</head>
<body class="p-4 flex items-center justify-center min-h-screen">

    <!-- Main App Screen (Lobby) -->
    <div id="lobby-screen" class="gruvbox-card rounded-lg p-8 w-full max-w-2xl">
        <h1 class="text-3xl font-bold mb-4 text-green">Parent-Teacher Video Lobby</h1>
        <p class="mb-2 text-fg-dark">Your User ID: <span class="font-mono text-purple" id="display-user-id">Loading...</span></p>
        <p class="mb-2 text-fg-dark">Please enter your name to be seen by others.</p>
        <input type="text" id="username-input" placeholder="Your Name" class="w-full p-3 mb-4 rounded bg-bg-dark text-fg-light placeholder-fg-dark focus:outline-none focus:ring-2 focus:ring-purple border border-fg-dark">
        
        <div class="md:flex md:space-x-4 mb-4">
            <!-- User List -->
            <div class="flex-1">
                <h2 class="text-xl font-bold mb-2 text-aqua">Online Users</h2>
                <div id="user-list" class="user-list p-4 rounded bg-bg-dark overflow-y-auto space-y-2">
                    <p class="text-center text-fg-dark">No other users online yet...</p>
                </div>
            </div>

            <!-- Chat -->
            <div class="flex-1 mt-4 md:mt-0">
                <h2 class="text-xl font-bold mb-2 text-aqua">Chat</h2>
                <div id="chat-messages" class="chat-container p-4 rounded bg-bg-dark overflow-y-auto mb-2 space-y-2">
                    <!-- Chat messages will be dynamically added here -->
                </div>
                <form id="chat-form" class="flex">
                    <input type="text" id="chat-input" placeholder="Type a message..." class="flex-1 p-3 rounded-l bg-bg-dark text-fg-light placeholder-fg-dark focus:outline-none focus:ring-2 focus:ring-purple border border-fg-dark">
                    <button type="submit" class="btn py-3 px-4 rounded-r font-bold">Send</button>
                </form>
            </div>
        </div>
        
    </div>

    <!-- Call Screen -->
    <div id="call-screen" class="hidden gruvbox-card rounded-lg p-8 w-full max-w-4xl">
        <h1 class="text-3xl font-bold mb-4 text-orange text-center">In Call</h1>
        <p class="mb-4 text-fg-dark text-center">You are connected with <span id="remote-user-name" class="font-bold text-yellow"></span>.</p>

        <div id="call-screen-videos" class="flex flex-col md:flex-row gap-4 mb-4">
            <video id="local-video" autoplay muted playsinline class="w-full md:w-1/2 rounded-lg"></video>
            <video id="remote-video" autoplay playsinline class="w-full md:w-1/2 rounded-lg"></video>
        </div>

        <div class="flex justify-center space-x-4">
            <button id="hangup-btn" class="btn-red py-3 px-6 rounded-lg font-bold">End Call</button>
        </div>
    </div>
    
    <!-- Custom Modal for Alerts -->
    <div id="alert-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="bg-bg-medium text-fg-light p-6 rounded-lg shadow-lg max-w-sm w-full">
            <div id="modal-message" class="text-center mb-4 text-lg"></div>
            <div class="flex justify-center">
                <button id="modal-ok-btn" class="btn py-2 px-6 rounded-lg">OK</button>
            </div>
        </div>
    </div>

    <!-- Custom Modal for Incoming Calls -->
    <div id="call-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="bg-bg-medium text-fg-light p-6 rounded-lg shadow-lg max-w-sm w-full">
            <div id="call-modal-message" class="text-center mb-4 text-lg font-bold text-yellow"></div>
            <div class="flex justify-center space-x-4">
                <button id="call-accept-btn" class="btn-green py-2 px-6 rounded-lg font-bold">Accept</button>
                <button id="call-decline-btn" class="btn-red py-2 px-6 rounded-lg font-bold">Decline</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "AIzaSyBluS1Dl9abDJjPPeOhvTCfP8J1kyIh6BQ",
            authDomain: "video-meeting-e73eb.firebaseapp.com",
            projectId: "video-meeting-e73eb",
            storageBucket: "video-meeting-e73eb.firebasestorage.app",
            messagingSenderId: "80496795033",
            appId: "1:80496795033:web:3ac35c631d76301f77c708",
            measurementId: "G-SFPQ0PJRPG"
        };
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // UI Elements
        const lobbyScreen = document.getElementById('lobby-screen');
        const callScreen = document.getElementById('call-screen');
        const usernameInput = document.getElementById('username-input');
        const displayUserIdSpan = document.getElementById('display-user-id');
        const userListDiv = document.getElementById('user-list');
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');
        const remoteUserNameSpan = document.getElementById('remote-user-name');
        const hangupBtn = document.getElementById('hangup-btn');
        const chatMessagesDiv = document.getElementById('chat-messages');
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        const alertModal = document.getElementById('alert-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalOkBtn = document.getElementById('modal-ok-btn');
        const callModal = document.getElementById('call-modal');
        const callModalMessage = document.getElementById('call-modal-message');
        const callAcceptBtn = document.getElementById('call-accept-btn');
        const callDeclineBtn = document.getElementById('call-decline-btn');

        // Firebase variables
        let app, auth, db;
        let userId;

        // WebRTC variables
        let localStream;
        let peerConnection;
        let currentCallId;
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' }
            ]
        };

        /**
         * Displays a custom modal with a message.
         * @param {string} message The message to display.
         */
        function showAlert(message) {
            modalMessage.textContent = message;
            alertModal.classList.remove('hidden');
        }

        modalOkBtn.addEventListener('click', () => {
            alertModal.classList.add('hidden');
        });

        /**
         * Shows the incoming call modal and returns a promise that resolves when a button is clicked.
         * @param {string} callerName The name of the person calling.
         * @returns {Promise<boolean>} Resolves to true if accepted, false if declined.
         */
        function showIncomingCallModal(callerName) {
            return new Promise(resolve => {
                callModalMessage.textContent = `Incoming call from ${callerName}!`;
                callModal.classList.remove('hidden');

                const onAccept = () => {
                    callModal.classList.add('hidden');
                    callAcceptBtn.removeEventListener('click', onAccept);
                    callDeclineBtn.removeEventListener('click', onDecline);
                    resolve(true);
                };
                const onDecline = () => {
                    callModal.classList.add('hidden');
                    callAcceptBtn.removeEventListener('click', onAccept);
                    callDeclineBtn.removeEventListener('click', onDecline);
                    resolve(false);
                };

                callAcceptBtn.addEventListener('click', onAccept);
                callDeclineBtn.addEventListener('click', onDecline);
            });
        }

        // Initialize Firebase
        function setupFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                console.log('Firebase initialized.');
            } catch (e) {
                console.error("Firebase initialization failed:", e);
                showAlert("Failed to initialize Firebase. Please check your config.");
            }
        }

        async function signInAndSetup() {
            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Sign-in failed:", error);
                showAlert("Sign-in failed. Please try again.");
            }
        }
        
        async function startLocalStream() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                console.log('Local stream started.');
            } catch (e) {
                console.error("Error starting local stream:", e);
                showAlert("Could not access camera/microphone. Please allow access.");
                return false;
            }
            return true;
        }

        /**
         * Updates the user's presence in Firestore.
         * @param {string} username The name of the user.
         */
        async function updatePresence(username) {
            if (!userId) {
                console.error("User ID is not set. Cannot update presence.");
                return;
            }
            const userDocRef = doc(db, `/artifacts/${appId}/public/data/users`, userId);
            try {
                await setDoc(userDocRef, {
                    name: username,
                    timestamp: serverTimestamp(),
                    isOnline: true,
                }, { merge: true });
                console.log('Presence updated for user:', username);
            } catch (e) {
                console.error("Error updating presence:", e);
            }
        }
        
        /**
         * Renders the list of online users in the lobby.
         * @param {Array} users The list of user objects.
         */
        function renderUserList(users) {
            userListDiv.innerHTML = '';
            const otherUsers = users.filter(u => u.id !== userId);
            if (otherUsers.length === 0) {
                userListDiv.innerHTML = '<p class="text-center text-fg-dark">No other users online yet...</p>';
                return;
            }

            otherUsers.forEach(user => {
                const userItem = document.createElement('div');
                userItem.className = 'flex items-center justify-between p-2 bg-bg-medium rounded-lg';
                userItem.innerHTML = `
                    <div class="flex flex-col">
                      <span class="font-semibold text-fg-light">${user.name}</span>
                      <span class="text-xs text-fg-dark font-mono">${user.id}</span>
                    </div>
                    <button class="btn-green py-1 px-4 rounded-full text-sm font-bold call-btn" data-user-id="${user.id}" data-user-name="${user.name}">Call</button>
                `;
                userListDiv.appendChild(userItem);
            });
        }

        /**
         * Creates a new call document in Firestore and initiates the call.
         * @param {string} calleeId The user ID of the person to call.
         * @param {string} calleeName The name of the person to call.
         */
        async function createCall(calleeId, calleeName) {
            if (!localStream) {
                showAlert("Please allow camera and mic access first.");
                return;
            }
            
            // Create call document
            const callsCollection = collection(db, `/artifacts/${appId}/public/data/calls`);
            const callDoc = await addDoc(callsCollection, {
                callerId: userId,
                callerName: usernameInput.value || `User ${userId.substring(0, 4)}`,
                calleeId: calleeId,
                timestamp: serverTimestamp(),
                status: 'pending'
            });
            currentCallId = callDoc.id;
            console.log("Call document created with ID:", currentCallId);

            // Setup WebRTC peer connection
            peerConnection = new RTCPeerConnection(configuration);
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            // Listen for remote track
            peerConnection.ontrack = (event) => {
                console.log('Remote track received.');
                remoteVideo.srcObject = event.streams[0];
                switchScreen('call');
                remoteUserNameSpan.textContent = calleeName;
            };

            // Listen for ICE candidates and send them to Firestore
            peerConnection.onicecandidate = async (event) => {
                if (event.candidate) {
                    await addDoc(collection(doc(callsCollection, currentCallId), 'callerCandidates'), event.candidate.toJSON());
                }
            };

            // Create and send offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            // Update call document with offer
            await updateDoc(doc(callsCollection, currentCallId), {
                offer: {
                    sdp: offer.sdp,
                    type: offer.type
                }
            });
        }

        /**
         * Handles an incoming offer, sets up peer connection, and sends an answer.
         * @param {string} callId The ID of the call document.
         * @param {Object} offer The offer SDP object.
         */
        async function handleOffer(callId, offer, callerName) {
            if (!localStream) {
                showAlert("Please allow camera and mic access first.");
                return;
            }
            if (peerConnection) {
                console.log("Already in a call, ignoring new offer.");
                return;
            }
            
            currentCallId = callId;
            const callsCollection = collection(db, `/artifacts/${appId}/public/data/calls`);

            peerConnection = new RTCPeerConnection(configuration);
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            peerConnection.ontrack = (event) => {
                console.log('Remote track received.');
                remoteVideo.srcObject = event.streams[0];
                switchScreen('call');
                remoteUserNameSpan.textContent = callerName;
            };

            peerConnection.onicecandidate = async (event) => {
                if (event.candidate) {
                    await addDoc(collection(doc(callsCollection, currentCallId), 'calleeCandidates'), event.candidate.toJSON());
                }
            };
            
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            await updateDoc(doc(callsCollection, currentCallId), {
                answer: {
                    sdp: answer.sdp,
                    type: answer.type
                }
            });

            // Start listening for candidates from the caller
            onSnapshot(collection(doc(callsCollection, currentCallId), 'callerCandidates'), (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === 'added') {
                        const candidate = new RTCIceCandidate(change.doc.data());
                        try {
                            await peerConnection.addIceCandidate(candidate);
                        } catch (e) {
                            console.error("Error adding caller ICE candidate:", e);
                        }
                    }
                });
            });
        }
        
        /**
         * Ends the current call and cleans up resources.
         */
        async function endCall() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            
            if (currentCallId) {
                const callDocRef = doc(db, `/artifacts/${appId}/public/data/calls`, currentCallId);
                // Use a try-catch for deleteDoc in case the other user already deleted it
                try {
                     await deleteDoc(callDocRef);
                } catch(e) {
                    console.log("Call document already deleted, no need to delete again.");
                }
                currentCallId = null;
            }
            switchScreen('lobby');
        }

        /**
         * Switches the display to the specified screen.
         * @param {string} screen The name of the screen ('lobby', 'call').
         */
        function switchScreen(screen) {
            lobbyScreen.classList.add('hidden');
            callScreen.classList.add('hidden');
            if (screen === 'lobby') lobbyScreen.classList.remove('hidden');
            if (screen === 'call') callScreen.classList.remove('hidden');
        }

        /**
         * Starts all real-time listeners for presence, calls, and chat.
         */
        function startListeners() {
            // Set up a listener for the presence collection
            onSnapshot(collection(db, `/artifacts/${appId}/public/data/users`), (snapshot) => {
                const users = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderUserList(users);
            });
            
            // Set up a listener for incoming calls
            onSnapshot(collection(db, `/artifacts/${appId}/public/data/calls`), async (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    const callData = change.doc.data();
                    if (change.type === 'added' && callData.calleeId === userId && !callData.answer) {
                        const callId = change.doc.id;
                        const isAccepted = await showIncomingCallModal(callData.callerName);
                        
                        if (isAccepted) {
                            await handleOffer(callId, callData.offer, callData.callerName);
                            // Start listening for caller's candidates
                            onSnapshot(collection(db, `/artifacts/${appId}/public/data/calls/${callId}/callerCandidates`), (snapshot) => {
                                snapshot.docChanges().forEach(async (change) => {
                                    if (change.type === 'added') {
                                        const candidate = new RTCIceCandidate(change.doc.data());
                                        try {
                                            await peerConnection.addIceCandidate(candidate);
                                        } catch (e) {
                                            console.error("Error adding caller ICE candidate:", e);
                                        }
                                    }
                                });
                            });
                        } else {
                            // Decline the call
                            await deleteDoc(change.doc.ref);
                        }
                    } else if (change.type === 'modified' && callData.callerId === userId && callData.answer) {
                        // Handle the answer from the callee
                        try {
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(callData.answer));
                            // Start listening for callee's candidates
                            onSnapshot(collection(db, `/artifacts/${appId}/public/data/calls/${currentCallId}/calleeCandidates`), (snapshot) => {
                                snapshot.docChanges().forEach(async (change) => {
                                    if (change.type === 'added') {
                                        const candidate = new RTCIceCandidate(change.doc.data());
                                        try {
                                            await peerConnection.addIceCandidate(candidate);
                                        } catch (e) {
                                            console.error("Error adding callee ICE candidate:", e);
                                        }
                                    }
                                });
                            });
                        } catch (e) {
                            console.error("Error setting remote description from answer:", e);
                        }
                    } else if (change.type === 'removed' && change.doc.id === currentCallId) {
                        endCall();
                        showAlert("Call ended.");
                    }
                });
            });
            
            // Set up a listener for chat messages
            onSnapshot(collection(db, `/artifacts/${appId}/public/data/chat`), (snapshot) => {
                chatMessagesDiv.innerHTML = '';
                const messages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                // Sort by timestamp in memory
                messages.sort((a, b) => a.timestamp - b.timestamp);
                messages.forEach(msg => {
                    const msgElement = document.createElement('div');
                    msgElement.className = 'flex flex-col';
                    msgElement.innerHTML = `<span class="font-bold text-yellow">${msg.sender}:</span><span>${msg.text}</span>`;
                    chatMessagesDiv.appendChild(msgElement);
                });
                chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
            });
        }

        // Event Listeners
        window.onload = async () => {
            setupFirebase();
            await signInAndSetup();
            await startLocalStream();
            
            // This is the correct place to register the onAuthStateChanged listener
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    displayUserIdSpan.textContent = userId;
                    console.log('User signed in:', userId);
                    startListeners();
                    updatePresence(usernameInput.value || `User ${userId.substring(0, 4)}`);
                } else {
                    console.log('User not signed in. Attempting anonymous sign-in.');
                    userId = crypto.randomUUID();
                    displayUserIdSpan.textContent = userId;
                    startListeners();
                    updatePresence(usernameInput.value || `User ${userId.substring(0, 4)}`);
                }
            });
        };

        usernameInput.addEventListener('input', () => {
            const username = usernameInput.value.trim() || `User ${userId.substring(0, 4)}`;
            updatePresence(username);
        });

        // Delegate click event for the dynamically added call buttons
        userListDiv.addEventListener('click', (e) => {
            if (e.target.classList.contains('call-btn')) {
                const calleeId = e.target.getAttribute('data-user-id');
                const calleeName = e.target.getAttribute('data-user-name');
                createCall(calleeId, calleeName);
            }
        });

        hangupBtn.addEventListener('click', endCall);

        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const messageText = chatInput.value.trim();
            if (messageText) {
                await addDoc(collection(db, `/artifacts/${appId}/public/data/chat`), {
                    sender: usernameInput.value || `User ${userId.substring(0, 4)}`,
                    text: messageText,
                    timestamp: serverTimestamp()
                });
                chatInput.value = '';
            }
        });

    </script>
</body>
</html>
