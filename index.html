import React, { useState, useEffect, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, setDoc, onSnapshot, collection, addDoc, getDoc, updateDoc, deleteDoc } from 'firebase/firestore';
import { getDatabase, ref, onValue, set, remove } from 'firebase/database';

// Global variables provided by the environment
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : '';

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const rtdb = getDatabase(app);
const auth = getAuth(app);

// WebRTC STUN servers
const servers = {
  iceServers: [
    {
      urls: ['stun:stun1.l.google.com:19302', 'stun:stun2.l.google.com:19302'],
    },
  ],
  iceCandidatePoolSize: 10,
};

// Global WebRTC variables
let pc = new RTCPeerConnection(servers);
let localStream = null;
let remoteStream = null;

const App = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [isAuthReady, setIsAuthReady] = useState(false);
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const [isAdmin, setIsAdmin] = useState(false);
  const [lobbyMessages, setLobbyMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [activeUsers, setActiveUsers] = useState({});
  const [callState, setCallState] = useState('idle'); // 'idle', 'ringing', 'calling', 'in_call'
  const [callingUser, setCallingUser] = useState(null);
  const [callId, setCallId] = useState('');
  const [callOffer, setCallOffer] = useState(null);
  const [showCallNotification, setShowCallNotification] = useState(false);
  const [isCameraOn, setIsCameraOn] = useState(true);
  const [isMicOn, setIsMicOn] = useState(true);
  const [alertMessage, setAlertMessage] = useState('');
  const [showAlert, setShowAlert] = useState(false);

  // Refs for video elements
  const localVideoRef = useRef(null);
  const remoteVideoRef = useRef(null);
  const callDocRef = useRef(null);

  // Auth state listener and Firebase initialization
  useEffect(() => {
    onAuthStateChanged(auth, async (user) => {
      if (user) {
        setIsLoggedIn(true);
        // The isAdmin flag is set when the admin signs in.
        // We'll use a custom claim to make this secure in a real application.
        // For this demo, we'll store it client-side.
        if (user.uid === 'admin') { // This check is a placeholder for a more robust admin check
          setIsAdmin(true);
        }
        setIsAuthReady(true);

        // Update user presence in Realtime Database
        const userRef = ref(rtdb, `users/${user.uid}`);
        await set(userRef, {
          username: user.displayName,
          isAdmin: user.uid === 'admin',
          timestamp: new Date().toISOString()
        });

        // Remove user from presence on disconnect
        userRef.onDisconnect().remove();

      } else {
        setIsLoggedIn(false);
        setIsAuthReady(true);
      }
    });

    if (initialAuthToken) {
      signInWithCustomToken(auth, initialAuthToken).catch(e => {
        console.error("Custom token sign-in failed:", e);
        signInAnonymously(auth);
      });
    } else {
      signInAnonymously(auth);
    }
  }, []);

  // Lobby logic: Fetch users and chat messages
  useEffect(() => {
    if (!isLoggedIn) return;

    // Listen for active users from Realtime Database
    const usersRef = ref(rtdb, 'users');
    const unsubscribeUsers = onValue(usersRef, (snapshot) => {
      const data = snapshot.val();
      if (data) {
        const users = Object.keys(data).reduce((acc, uid) => {
          if (uid !== auth.currentUser.uid) {
            acc[uid] = data[uid];
          }
          return acc;
        }, {});
        setActiveUsers(users);
      } else {
        setActiveUsers({});
      }
    });

    // Listen for lobby chat messages from Firestore
    const lobbyRef = collection(db, 'lobbyChat');
    const unsubscribeChat = onSnapshot(lobbyRef, (snapshot) => {
      const messages = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
      })).sort((a, b) => a.timestamp - b.timestamp);
      setLobbyMessages(messages);
    });

    return () => {
      unsubscribeUsers();
      unsubscribeChat();
    };
  }, [isLoggedIn]);

  // Handle call state changes and WebRTC setup
  useEffect(() => {
    // This effect runs only when a call is initiated or received.
    const handleCallStateChange = async () => {
      if (callState === 'calling' || callState === 'ringing') {
        try {
          // Get local media stream
          localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
          if (localVideoRef.current) {
            localVideoRef.current.srcObject = localStream;
          }

          // Add local tracks to peer connection
          localStream.getTracks().forEach((track) => {
            pc.addTrack(track, localStream);
          });

          // Handle remote stream
          pc.ontrack = (event) => {
            remoteStream = event.streams[0];
            if (remoteVideoRef.current) {
              remoteVideoRef.current.srcObject = remoteStream;
            }
          };

          // Handle ICE candidates
          pc.onicecandidate = async (event) => {
            if (event.candidate) {
              const candidate = event.candidate.toJSON();
              await addDoc(collection(callDocRef.current, 'iceCandidates'), candidate);
            }
          };

          // Admin initiates the call
          if (callState === 'calling') {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            // Set the document ID for the call
            const newCallDocRef = doc(db, 'calls', callId);
            callDocRef.current = newCallDocRef;
            await setDoc(newCallDocRef, {
              adminId: auth.currentUser.uid,
              clientId: callingUser.id,
              offer: {
                type: offer.type,
                sdp: offer.sdp,
              },
              status: 'ringing',
              timestamp: Date.now(),
            });

            // Listen for answer
            onSnapshot(newCallDocRef, async (snapshot) => {
              const data = snapshot.data();
              if (data?.answer && !pc.currentRemoteDescription) {
                const answer = new RTCSessionDescription(data.answer);
                await pc.setRemoteDescription(answer);
              }
            });

          // Client receives the call
          } else if (callState === 'ringing' && callOffer) {
            await pc.setRemoteDescription(new RTCSessionDescription(callOffer));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);

            await updateDoc(callDocRef.current, {
              answer: {
                type: answer.type,
                sdp: answer.sdp,
              },
              status: 'in_call'
            });
          }

          // Listen for ICE candidates
          onSnapshot(collection(callDocRef.current, 'iceCandidates'), (snapshot) => {
            snapshot.docChanges().forEach(async (change) => {
              if (change.type === 'added') {
                const candidate = new RTCIceCandidate(change.doc.data());
                await pc.addIceCandidate(candidate);
              }
            });
          });

          setCallState('in_call');

        } catch (error) {
          console.error("Error setting up video call:", error);
          handleCallEnd();
        }
      }
    };

    handleCallStateChange();

    return () => {
      // Clean up on component unmount
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
      if (pc) {
        pc.close();
        pc = new RTCPeerConnection(servers);
      }
    };
  }, [callState, callId, callOffer]);

  // Listen for incoming calls for regular users
  useEffect(() => {
    if (isAdmin || !isLoggedIn || !isAuthReady) return;

    const q = collection(db, 'calls');
    const unsubscribe = onSnapshot(q, (snapshot) => {
      snapshot.docChanges().forEach((change) => {
        if (change.type === 'added') {
          const callData = change.doc.data();
          if (callData.clientId === auth.currentUser.uid && callData.status === 'ringing') {
            setCallId(change.doc.id);
            setCallOffer(callData.offer);
            setCallingUser({ id: callData.adminId, username: 'Admin' });
            setShowCallNotification(true);
            setCallState('ringing');
          }
        }
      });
    });

    return () => unsubscribe();
  }, [isLoggedIn, isAdmin, isAuthReady]);

  const handleLogin = (e) => {
    e.preventDefault();
    if (username.toLowerCase() === 'admin' && password === 'max') {
      // For this demo, we'll use a placeholder UID for admin. In a real app, Firebase Auth handles this.
      auth.currentUser.updateProfile({ displayName: 'Admin' });
      setIsAdmin(true);
      setIsLoggedIn(true);
    } else if (username && username.toLowerCase() !== 'admin') {
      auth.currentUser.updateProfile({ displayName: username });
      setIsLoggedIn(true);
    } else {
      setAlertMessage("Invalid username or password.");
      setShowAlert(true);
    }
  };

  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (newMessage.trim() === '') return;

    await addDoc(collection(db, 'lobbyChat'), {
      username: auth.currentUser.displayName,
      message: newMessage,
      timestamp: Date.now(),
    });
    setNewMessage('');
  };

  const handleInitiateCall = (user) => {
    setCallState('calling');
    setCallingUser(user);
    setCallId(`${auth.currentUser.uid}-${user.id}`);
  };

  const handleCallEnd = async () => {
    // Stop tracks
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
    }
    // Close peer connection
    if (pc) {
      pc.close();
      pc = new RTCPeerConnection(servers);
    }
    // Clear Firestore call document
    if (callDocRef.current) {
      await deleteDoc(callDocRef.current);
    }

    setCallState('idle');
    setCallingUser(null);
    setCallId('');
    setCallOffer(null);
    setShowCallNotification(false);
  };

  const toggleCamera = () => {
    localStream.getVideoTracks()[0].enabled = !isCameraOn;
    setIsCameraOn(!isCameraOn);
  };

  const toggleMic = () => {
    localStream.getAudioTracks()[0].enabled = !isMicOn;
    setIsMicOn(!isMicOn);
  };

  const renderLobby = () => (
    <div className="flex flex-col h-full bg-gray-900 text-white p-4">
      <div className="flex justify-between items-center mb-4">
        <h1 className="text-3xl font-bold text-gray-200">VideoConf Doral</h1>
        <div className="flex items-center space-x-2">
          <span className="text-lg">Logged in as: <span className="font-semibold text-green-400">{auth.currentUser?.displayName}</span></span>
          <span className="text-sm text-gray-400">({auth.currentUser?.uid})</span>
        </div>
      </div>

      <div className="flex-1 flex flex-col lg:flex-row space-y-4 lg:space-y-0 lg:space-x-4 overflow-hidden">
        {/* Active Users */}
        <div className="bg-gray-800 rounded-lg p-4 flex-none lg:w-1/4 flex flex-col overflow-y-auto">
          <h2 className="text-xl font-semibold mb-2 text-gray-300">Active Users</h2>
          <ul className="space-y-2">
            {Object.entries(activeUsers).map(([uid, user]) => (
              <li key={uid} className="bg-gray-700 p-3 rounded-md flex justify-between items-center">
                <span className="text-gray-200">{user.username}</span>
                {isAdmin && (
                  <button
                    onClick={() => handleInitiateCall({ id: uid, username: user.username })}
                    className="ml-2 px-3 py-1 bg-purple-500 hover:bg-purple-600 rounded-lg text-white font-medium text-sm transition-colors duration-200"
                  >
                    Call
                  </button>
                )}
              </li>
            ))}
          </ul>
        </div>

        {/* Chat Area */}
        <div className="flex-1 bg-gray-800 rounded-lg p-4 flex flex-col">
          <h2 className="text-xl font-semibold mb-2 text-gray-300">Lobby Chat</h2>
          <div className="flex-1 overflow-y-auto space-y-3 pb-4">
            {lobbyMessages.map((msg, index) => (
              <div key={index} className="flex flex-col">
                <span className="text-gray-400 text-sm">{msg.username} <span className="text-xs text-gray-500">{new Date(msg.timestamp).toLocaleTimeString()}</span></span>
                <p className="text-gray-100">{msg.message}</p>
              </div>
            ))}
          </div>
          <form onSubmit={handleSendMessage} className="flex mt-4">
            <input
              type="text"
              value={newMessage}
              onChange={(e) => setNewMessage(e.target.value)}
              placeholder="Send a message..."
              className="flex-1 p-2 rounded-lg bg-gray-700 text-gray-200 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500"
            />
            <button
              type="submit"
              className="ml-2 px-4 py-2 bg-purple-500 hover:bg-purple-600 rounded-lg text-white font-medium transition-colors duration-200"
            >
              Send
            </button>
          </form>
        </div>
      </div>

      {showCallNotification && (
        <div className="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50">
          <div className="bg-gray-800 p-8 rounded-lg shadow-lg text-center">
            <h3 className="text-2xl font-bold mb-4">Incoming Call</h3>
            <p className="text-lg">You have an incoming call from <span className="font-semibold text-green-400">{callingUser?.username}</span></p>
            <div className="mt-6 flex justify-center space-x-4">
              <button
                onClick={() => setShowCallNotification(false)}
                className="px-6 py-2 bg-green-500 hover:bg-green-600 rounded-full text-white font-bold transition-colors duration-200"
              >
                Accept
              </button>
              <button
                onClick={handleCallEnd}
                className="px-6 py-2 bg-red-500 hover:bg-red-600 rounded-full text-white font-bold transition-colors duration-200"
              >
                Decline
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );

  const renderVideoCall = () => (
    <div className="flex flex-col h-full bg-gray-900 p-4">
      <div className="flex justify-between items-center mb-4">
        <h1 className="text-3xl font-bold text-gray-200">Video Call with <span className="text-green-400">{callingUser.username}</span></h1>
      </div>
      <div className="flex-1 relative flex items-center justify-center">
        {/* Remote Video */}
        <video ref={remoteVideoRef} autoPlay playsInline className="w-full h-full object-cover rounded-lg"></video>

        {/* Local Video */}
        <video ref={localVideoRef} muted autoPlay playsInline className="absolute bottom-4 right-4 w-48 h-36 border-4 border-gray-700 rounded-lg shadow-lg"></video>
      </div>

      {/* Controls */}
      <div className="flex justify-center space-x-4 mt-4">
        <button onClick={toggleMic} className="p-3 rounded-full bg-gray-700 text-white hover:bg-gray-600 transition-colors duration-200">
          {isMicOn ? <i className="fas fa-microphone"></i> : <i className="fas fa-microphone-slash"></i>}
        </button>
        <button onClick={toggleCamera} className="p-3 rounded-full bg-gray-700 text-white hover:bg-gray-600 transition-colors duration-200">
          {isCameraOn ? <i className="fas fa-video"></i> : <i className="fas fa-video-slash"></i>}
        </button>
        <button onClick={handleCallEnd} className="p-3 rounded-full bg-red-500 text-white hover:bg-red-600 transition-colors duration-200">
          <i className="fas fa-phone-slash"></i>
        </button>
      </div>
    </div>
  );

  return (
    <div className="h-screen w-screen bg-gray-900 font-sans text-white">
      {/* Tailwind and Font Awesome */}
      <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet" />
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" />

      {showAlert && (
        <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50">
          <div className="bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm text-center">
            <h3 className="text-xl font-bold mb-2 text-red-400">Error</h3>
            <p className="text-gray-300 mb-4">{alertMessage}</p>
            <button onClick={() => setShowAlert(false)} className="px-4 py-2 bg-purple-500 rounded-md hover:bg-purple-600">Close</button>
          </div>
        </div>
      )}

      {!isLoggedIn || !isAuthReady ? (
        <div className="flex items-center justify-center h-full bg-gray-900">
          <div className="bg-gray-800 p-8 rounded-xl shadow-lg w-full max-w-md">
            <div className="flex justify-center mb-6">
              <img src="https://content.enrollmystudent.org/contact_school_logo/school_logo_1655490559.jpg" alt="Company Logo" className="h-20" />
            </div>
            <h2 className="text-2xl font-bold text-center mb-6 text-gray-200">Join VideoConf Doral</h2>
            <form onSubmit={handleLogin} className="space-y-4">
              <input
                type="text"
                value={username}
                onChange={(e) => {
                  setUsername(e.target.value);
                  setShowPassword(e.target.value.toLowerCase() === 'admin');
                }}
                placeholder="Enter your username"
                className="w-full p-3 rounded-lg bg-gray-700 text-gray-200 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500"
              />
              {showPassword && (
                <input
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="Enter admin password"
                  className="w-full p-3 rounded-lg bg-gray-700 text-gray-200 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500"
                />
              )}
              <button
                type="submit"
                className="w-full p-3 bg-purple-500 hover:bg-purple-600 rounded-lg text-white font-bold transition-colors duration-200"
              >
                Join
              </button>
            </form>
          </div>
        </div>
      ) : (
        <div className="h-full">
          {callState === 'idle' && renderLobby()}
          {(callState === 'calling' || callState === 'ringing' || callState === 'in_call') && renderVideoCall()}
        </div>
      )}
    </div>
  );
};

export default App;
